### 다차원 배열 다루기 2

### 슬라이싱
파이썬 리스트와 유사하게, Numpy 배열도 슬라이싱이 가능하다.
Numpy 배열은 다차원인 경우가 많기에, 각 차원별로 어떻게 슬라이스할건지 명확히 해야한다.
Nunpy 배열을 슬라이싱하면, 연속된 값을 가져오기에 결과로 얻어지는 배열은 언제나 원본 배열의 부분 배열이다.

항상 주의해야하는게 슬라이싱에서 시작값은 포함하지만 끝 값은 포함하지 않는다.
 ``` Python
#a[ : , : ]
#a[행 슬라이싱 시작:행 슬라이싱 끝, 열 슬라이싱 시작 : 열 슬라이싱 끝]

import numpy as np

# shape가 (3, 4)인 2차원 배열 생성
# [[ 1  2  3  4]
#  [ 5  6  7  8]
#  [ 9 10 11 12]]
a = np.array([[1,2,3,4], [5,6,7,8], [9,10,11,12]])

a[0:2, 0:4]

#시작값이 0인 경우 생략 가능하며 끝 값이 shape의 값과 동일한 경우 생략 가능하다.

a[:2, :]
#위 코드는 열을 슬라이싱 하지 않는 코드이며 이런 경우 열 부분은 전체 생략 가능하다.

a[:2]
```

-----
### 인덱싱

인덱싱을 통해 원소에 접근할 수 있다.
두가지 표현 방법이 있다.

```Python
a[0,0]
a[0][0]

# Numpy 배열을 슬라이싱하면, 연속된 값을 가져오기에 결과로 얻어지는 배열은 언제나 원본 배열의 부분 배열이다.
# 그러나 인덱싱을 한다면, 연속하지 않은 값을 가져올 수 있으니 원본과 다른 배열을 만들 수 있다.

a
# 0행, 2행만 인덱싱
a[[0, 2], ]

# 0열, 1열, 3열만 인덱싱
a[:, [0,1,3]]

```

-----
### 인덱싱&슬라이싱 - 차원

정수 인덱싱과 슬라이싱을 혼합해서 사용하면 낮은 차원의 배열이 생성되지만,
슬라이싱만 사용하면 원본 배열과 동일한 차원의 배열이 생성된다.
0번째 행을 인덱싱하는 경우와 슬라이싱 하는 경우를 비교해보겠다.

``` Python
print(a, a.shape, a.ndim)

# 슬라이싱만 사용
slicedRow = a[0:1, :]
print(slicedRow, slicedRow.shape, slicedRow.ndim)

# 아래와 동일한 코드
# 인덱싱&슬라이싱 혼합 사용
indexedRow = a[0]
print(indexedRow, indexedRow.shape, indexedRow.ndim)

# 위와 동일한 코드
# 인덱싱&슬라이싱 혼합 사용
indexedRow2 = a[0, :]
print(indexedRow2, indexedRow2.shape, indexedRow2.ndim)

# 슬라이싱만 사용
slicedCol = a[:, 0:1]
print(slicedCol, slicedCol.shape, slicedCol.ndim)

# 인덱싱&슬라이싱 혼합 사용
indexedCol = a[:, 0]
print(indexedCol, indexedCol.shape, indexedCol.ndim)
```

다차원배열간 연산에서 차원이 달라 문제가 발생하는 경우가 종종 있다.

특별히 인덱싱을 써야 하는 상황이 아니라면, 인덱싱보다 슬라이싱을 추천한다.

------

### 인덱싱과 슬라이싱의 차이
- 인덱싱을 사용하면 차원이 낮아진다.
- 슬라이싱을 사용하면 차원이 유지된다.

### 인덱싱&슬라이싱 - 값 복사&참조

```Python
a

# 인덱싱해서 b에 대입
b = a[0, 0]

# b값 수정
b = 100

print("a[0, 0]: {}".format(a[0, 0]))
print("b: {}".format(b))

```

슬라이싱된 배열은 원본 배열과 같은 데이터를 참조한다.
**즉 슬라이싱된 배열을 수정하면 원본 배열 역시 수정된다.**


```Python
# a를 슬라이스하여 c 생성
c = a[1:3, 1:3]

print(c)

# c[0, 0]은 a[1, 1]과 같은 데이터입니다.
c[0, 0] = 100

print(c)
print('------------------')
print(a)
```
