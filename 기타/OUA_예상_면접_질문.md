# [OUA](https://github.com/Lanvizu/OUA_V1) : 해당 프로젝트에 관한 예상 면접 질문

## 1. 전체 프로젝트 개요 및 설계

### 💡이 프로젝트를 진행하게 된 배경과 목표는 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - 전체 설계부터 배포, 운영, 개선까지 전 과정을 혼자서 경험하는 것이 이 프로젝트의 주요 목표였습니다.
  
  - 처음에는 당근마켓 클론 코딩을 통해 그동안 학습한 Java 백엔드 기술을 실제 서비스 흐름에 적용해보려고 생각했습니다.
    
  - 프로젝트를 기획하면서 단순한 중고 거래보다는 실시간 경매 시스템을 구현하면 더 다양한 예외 상황과 복잡한 로직을 경험할 수 있을 것 같아, 경매 기능을 추가하게 되었습니다.
    
</details>

### 💡전체 아키텍처를 설명해 주세요.

<details>
  <summary>✅ 답변</summary>

  - 백엔드는 Spring Boot, 프론트엔드는 React로 구현했습니다.
  
  - 데이터베이스는 MySQL을 사용하여 사용자, 상품, 입찰 정보 등을 저장했습니다.
  
  - 이메일 인증 기능과 같은 일시적 데이터 저장에는 Redis를 사용했으며, TTL을 설정하여 인증 코드 만료를 관리했습니다.
  
  - Nginx는 리버스 프록시 역할을 하며 정적 파일 서빙과 HTTPS 처리를 담당합니다.
  
  - 모든 서비스는 Docker Compose를 통해 컨테이너화했고, AWS EC2 인스턴스에서 배포했습니다.
  
  - CI/CD는 GitHub Actions를 활용해 코드 푸시 시 자동으로 빌드 및 배포가 이루어지도록 구성했습니다.
    
</details>

### 💡이 프로젝트에서 가장 어려웠던 기술적 문제는 무엇이었고, 어떻게 해결했나요?

<details>
  <summary>✅ 답변</summary>

  - 가장 어려웠던 문제는 입찰 기능에서 발생한 동시성 제어 이슈였습니다.
  
  - 초기에는 별도의 제어 없이 로직을 처리했기 때문에 동시에 여러 사용자가 동일한 가격으로 입찰하는 경우, 잘못된 낙찰자가 결정되는 문제가 있었습니다.
  
  - 이를 해결하기 위해 Redis 기반의 분산 락을 적용했지만, 트랜잭션 커밋 전에 락이 먼저 해제되는 문제가 발생해 완벽한 동시성 제어가 어려웠습니다.
  
  - 이후 TransactionSynchronizationManager를 활용해 트랜잭션 커밋 이후에 락이 해제되도록 개선하여 안정적인 처리가 가능해졌습니다.
  
  - 하지만 단일 서버 환경에서는 분산 락이 오버엔지니어링이라고 판단되어, 최종적으로는 ReentrantLock을 활용해 각 상품별 동시 처리를 제어했습니다.
    
</details>


## 꼬리 질문:

### 💡혼자 개발한 프로젝트인데, 협업 상황에서는 어떤 방식으로 구조를 개선하거나 역할을 분배할 수 있을까요?

<details>
  <summary>✅ 답변</summary>

  - 협업 상황이라면 프론트엔드와 백엔드 팀으로 나눈 뒤, 백엔드에서는 도메인 또는 기능 단위로 역할을 분리해 개발을 진행할 것 같습니다.
  
  - 예를 들어, 사용자 인증/인가, 상품 관리, 입찰 기능 등을 각각 담당하도록 분담하고, 각 기능별로 API 명세 문서를 통해 팀 간 소통을 명확하게 진행하겠습니다.
  
  - 또한 Git 기반의 브랜치 전략과 코드리뷰 프로세스를 도입해 코드 품질을 높이고 싶습니다.
  
  - 정기적인 테스트와 공유 회의를 통해 기능 간 결합도를 조율하고 개선 방향을 함께 찾아나갈 것입니다.
</details>

### 💡실시간성 요구사항을 만족시키기 위해 어떤 설계적 고민을 했나요?
  
<details>
  <summary>✅ 답변</summary>

  - 실시간 경매 시스템 특성상, 경매 종료 시점을 정확하게 처리하는 것이 중요했습니다.
  
  - 이를 위해 Redis의 TTL 기능과 Key Expiration Event를 활용해 경매 마감 시점에 이벤트가 발생하도록 설정했습니다.
  
  - 이 이벤트를 감지하는 Redis Keyspace Listener를 통해 경매 종료 로직이 자동으로 실행되며, 최고 입찰자를 낙찰자로 지정하고 경매 상태를 변경합니다.
  
  - 또한, 입찰이나 상품 등록과 같은 일반적인 요청은 데이터베이스를 직접 조회하여 항상 최신 정보를 제공하도록 설계했습니다.
  
</details>

### 💡단일 서버 구성에서 발생할 수 있는 문제점은 무엇이 있을까요?
  
<details>
  <summary>✅ 답변</summary>

  - 단일 서버 구성에서는 하나의 서버에 모든 트래픽과 기능이 집중되기 때문에, 서버 장애 시 전체 서비스가 중단될 수 있습니다.
  
  - 또한 사용자 수가 늘어날수록 요청 처리에 대한 병목이 발생할 수 있으며, 확장성에도 한계가 있습니다.

  - 이를 해결하기 위해서는 서버를 여러 대로 확장하거나, 로드밸런서를 통해 트래픽을 분산하는 방법등이 있습니다.
  
  - 특히 동시성 제어와 관련하여, 현재는 ReentrantLock을 사용한 JVM 기반 락으로 처리를 하고 있지만, 다중 서버 환경에서는 이 방식이 동작하지 않기 때문에 Redis 기반의 분산 락으로 변경해야 합니다.

</details>

### 💡ReentrantLock 대신 Redis 분산 락을 선택해야 하는 상황은 어떤 경우인가요?

<details>
  <summary>✅ 답변</summary>

  - ReentrantLock은 JVM 내부 메모리에서만 동작하기 때문에, 단일 서버 환경에서는 유효하지만 다중 서버 환경에서는 각 서버가 서로 다른 JVM 인스턴스를 사용하므로 락이 공유되지 않습니다.

- 따라서 동일한 자원에 대한 동시 접근이 여러 서버에서 발생할 경우, ReentrantLock으로는 경쟁 조건을 방지할 수 없습니다.

- 이런 상황에서는 Redis 분산 락을 활용하여 모든 서버가 중앙의 Redis 인스턴스를 통해 락을 관리함으로써, 서버 간에도 일관된 동시성 제어가 가능해집니다.

- Redisson이나 Lettuce와 같은 라이브러리를 사용하면 분산 환경에서도 안전하게 락 획득 및 해제가 가능합니다.
  
</details>

### 💡Redis TTL 이벤트를 활용한 경매 종료 처리 방식의 한계나 리스크는 없을까요?

<details>
  <summary>✅ 답변</summary>

  - Redis TTL 기반의 Key Expiration Event는 Redis 서버 설정에 따라 비활성화되어 있을 수 있고, Redis 장애 발생 시 해당 이벤트가 유실될 가능성이 있습니다.
  
  - 또한 TTL 이벤트는 정확한 시간 보장을 하지 않기 때문에, 경매 종료 시점을 초 단위로 정밀하게 처리해야 하는 경우에는 신뢰성이 떨어질 수 있습니다.
  
  - 이러한 리스크를 보완하기 위해, 백엔드에서 주기적으로 경매 종료 시간을 체크하는 스케줄링 로직을 도입하거나, 데이터베이스 기반의 시간 조건 쿼리를 통해 경매 상태를 갱신하는 방식도 고려할 수 있습니다.
    
</details>

---

## ✅ **2. Spring Boot & 비즈니스 로직**

### 질문:

* 상품 등록/입찰/낙찰 등 주요 도메인 로직은 어떻게 설계하셨나요?
* 입찰 기능에서의 트랜잭션 처리 방식은 어떻게 되나요?
* 입찰 시 동시성 제어는 어떻게 구현하셨나요?

### 꼬리 질문:

* 비관적 락, 낙관적 락, 분산 락과 비교했을 때 ReentrantLock의 장단점은 무엇인가요?
* 동시성 처리 시 고려해야 할 이슈들은 어떤 게 있었나요?
* 서비스 레이어에서 발생 가능한 Race Condition 외에 또 어떤 케이스가 있었나요?

---

## ✅ **3. QueryDSL**

### 질문:

* QueryDSL을 사용한 이유는 무엇인가요?
* 검색 기능 구현 시 성능이나 유지보수 측면에서 어떤 장점이 있었나요?

### 꼬리 질문:

* QueryDSL 대신 JPA Criteria나 Specification을 사용할 수도 있는데 어떤 차이점이 있나요?
* 복잡한 검색 조건을 어떻게 동적으로 처리했나요?
* 페이징 처리 시 성능 이슈가 있었나요?

---

## ✅ **4. Redis & 인증 처리**

### 질문:

* Redis를 사용한 이유는 무엇인가요?
* 이메일 인증 기능은 어떤 구조로 동작하나요?

### 꼬리 질문:

* 인증 코드 TTL을 Redis에서 관리하는 이유는 무엇인가요?
* Redis 장애 시 어떤 방식으로 대처할 수 있을까요?
* Redis를 세션 저장소로도 사용할 수 있는데, 인증 코드 외에 어떻게 활용할 수 있나요?

---

## ✅ **5. JWT 기반 인증/인가**

### 질문:

* JWT 인증 흐름을 설명해 주세요.
* JWT 토큰의 유효성 검증은 어떤 방식으로 했나요?

### 꼬리 질문:

* JWT와 세션 기반 인증의 차이점은 무엇이라고 생각하나요?
* JWT에 어떤 정보를 담았으며, 보안상 어떻게 보호했나요?
* 리프레시 토큰은 구현하셨나요? 왜 또는 왜 안 했는지?

---

## ✅ **6. CI/CD with GitHub Actions**

### 질문:

* GitHub Actions로 어떤 자동화 작업을 했나요?
* CI/CD 파이프라인 구성을 설명해주세요.

### 꼬리 질문:

* `빌드 실패` 혹은 `배포 실패` 시 어떤 알림이나 롤백 전략이 있나요?
* 테스트는 어느 단계에서 진행되나요?
* CI/CD를 로컬에서 먼저 테스트해본 경험이 있나요?

---

## ✅ **7. Docker, Nginx, AWS EC2 배포**

### 질문:

* Docker Compose로 각 서비스를 어떻게 분리하고 구성했나요?
* Nginx는 어떤 역할을 하고 있나요?
* HTTPS 인증서는 어떻게 적용했나요?

### 꼬리 질문:

* Nginx의 리버스 프록시 설정은 어떻게 구성했나요?
* Let's Encrypt 인증서 갱신 자동화는 어떻게 했나요?
* EC2 단일 인스턴스에서 발생할 수 있는 문제점은?

---

## ✅ **8. 프론트엔드 (React)**

### 질문:

* 상품 등록/검색/입찰 UI는 어떤 방식으로 구현했나요?
* API 요청 구조 및 예외 처리 방식은 어떤 식으로 처리했나요?

### 꼬리 질문:

* REST API 호출 시 에러 핸들링은 어떻게 구성했나요?
* React Query 같은 데이터 패칭 라이브러리 사용 여부 및 이유는?
* 페이지네이션이나 무한 스크롤을 구현한 부분이 있나요?

---

## ✅ **9. 테스트 및 품질 관리**

### 질문:

* 어떤 테스트를 작성했나요? (단위/통합/인수)
* 테스트 자동화는 CI에 통합되었나요?

### 꼬리 질문:

* 입찰 로직 테스트에서 어떤 케이스들을 중점적으로 확인했나요?
* 테스트 커버리지를 높이기 위한 시도는 있었나요?

---

## ✅ **10. 성능/보안/운영 이슈**

### 질문:

* 이 프로젝트에서 보안적으로 신경 쓴 부분은 무엇인가요?
* 입찰과 같은 민감 로직에서 성능을 개선한 경험이 있나요?

### 꼬리 질문:

* HTTPS 설정을 통한 보안 외에 CSRF/XSS 등은 어떻게 대응했나요?
* DB 인덱싱, 캐싱 전략은 어떻게 고려했나요?

---

이 외에도 면접관은 이런 질문들을 기반으로 **"만약 실 서비스로 확장한다면?"** 이라는 방향의 질문도 자주 던집니다.
예:

* 트래픽이 많아지면 어떻게 확장할 건가요?
* 서버가 여러 개로 분산될 때 락 처리 방식은 어떻게 바뀌어야 하나요?
* 모놀리식 구조 vs 마이크로서비스로 전환 가능성에 대해 어떻게 생각하나요?

