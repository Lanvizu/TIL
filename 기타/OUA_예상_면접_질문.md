# [OUA](https://github.com/Lanvizu/OUA_V1) : 해당 프로젝트에 관한 예상 면접 질문

## 1. 전체 프로젝트 개요 및 설계

### 이 프로젝트를 진행하게 된 배경과 목표는 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - 전체 설계부터 배포, 운영, 개선까지 전 과정을 혼자서 경험하는 것이 이 프로젝트의 주요 목표였습니다.
  
  - 처음에는 당근마켓 클론 코딩을 통해 그동안 학습한 Java 백엔드 기술을 실제 서비스 흐름에 적용해보려고 생각했습니다.
    
  - 프로젝트를 기획하면서 단순한 중고 거래보다는 실시간 경매 시스템을 구현하면 더 다양한 예외 상황과 복잡한 로직을 경험할 수 있을 것 같아, 경매 기능을 추가하게 되었습니다.
    
</details>

### 전체 아키텍처를 설명해 주세요.

<details>
  <summary>✅ 답변</summary>

  - 백엔드는 Spring Boot, 프론트엔드는 React로 구현했습니다.
  
  - 데이터베이스는 MySQL을 사용하여 사용자, 상품, 입찰 정보 등을 저장했습니다.
  
  - 이메일 인증 기능과 같은 일시적 데이터 저장에는 Redis를 사용했으며, TTL을 설정하여 인증 코드 만료를 관리했습니다.
  
  - Nginx는 리버스 프록시 역할을 하며 정적 파일 서빙과 HTTPS 처리를 담당합니다.
  
  - 모든 서비스는 Docker Compose를 통해 컨테이너화했고, AWS EC2 인스턴스에서 배포했습니다.
  
  - CI/CD는 GitHub Actions를 활용해 코드 푸시 시 자동으로 빌드 및 배포가 이루어지도록 구성했습니다.
    
</details>

### 이 프로젝트에서 가장 어려웠던 기술적 문제는 무엇이었고, 어떻게 해결했나요?

<details>
  <summary>✅ 답변</summary>

  - 가장 어려웠던 문제는 입찰 기능에서 발생한 동시성 제어 이슈였습니다.
  
  - 초기에는 별도의 제어 없이 로직을 처리했기 때문에 동시에 여러 사용자가 동일한 가격으로 입찰하는 경우, 잘못된 낙찰자가 결정되는 문제가 있었습니다.
  
  - 이를 해결하기 위해 Redis 기반의 분산 락을 적용했지만, 트랜잭션 커밋 전에 락이 먼저 해제되는 문제가 발생해 완벽한 동시성 제어가 어려웠습니다.
  
  - 이후 TransactionSynchronizationManager를 활용해 트랜잭션 커밋 이후에 락이 해제되도록 개선하여 안정적인 처리가 가능해졌습니다.
  
  - 하지만 단일 서버 환경에서는 분산 락이 오버엔지니어링이라고 판단되어, 최종적으로는 ReentrantLock을 활용해 각 상품별 동시 처리를 제어했습니다.
    
</details>


## 꼬리 질문:

### 혼자 개발한 프로젝트인데, 협업 상황에서는 어떤 방식으로 구조를 개선하거나 역할을 분배할 수 있을까요?

<details>
  <summary>✅ 답변</summary>

  - 협업 상황이라면 프론트엔드와 백엔드 팀으로 나눈 뒤, 백엔드에서는 도메인 또는 기능 단위로 역할을 분리해 개발을 진행할 것 같습니다.
  
  - 예를 들어, 사용자 인증/인가, 상품 관리, 입찰 기능 등을 각각 담당하도록 분담하고, 각 기능별로 API 명세 문서를 통해 팀 간 소통을 명확하게 진행하겠습니다.
  
  - 또한 Git 기반의 브랜치 전략과 코드리뷰 프로세스를 도입해 코드 품질을 높이고 싶습니다.
  
  - 정기적인 테스트와 공유 회의를 통해 기능 간 결합도를 조율하고 개선 방향을 함께 찾아나갈 것입니다.
</details>

### 실시간성 요구사항을 만족시키기 위해 어떤 설계적 고민을 했나요?
  
<details>
  <summary>✅ 답변</summary>

  - 실시간 경매 시스템 특성상, 경매 종료 시점을 정확하게 처리하는 것이 중요했습니다.
  
  - 이를 위해 Redis의 TTL 기능과 Key Expiration Event를 활용해 경매 마감 시점에 이벤트가 발생하도록 설정했습니다.
  
  - 이 이벤트를 감지하는 Redis Keyspace Listener를 통해 경매 종료 로직이 자동으로 실행되며, 최고 입찰자를 낙찰자로 지정하고 경매 상태를 변경합니다.
  
  - 또한, 입찰이나 상품 등록과 같은 일반적인 요청은 데이터베이스를 직접 조회하여 항상 최신 정보를 제공하도록 설계했습니다.
  
</details>

### 단일 서버 구성에서 발생할 수 있는 문제점은 무엇이 있을까요?
  
<details>
  <summary>✅ 답변</summary>

  - 단일 서버 구성에서는 하나의 서버에 모든 트래픽과 기능이 집중되기 때문에, 서버 장애 시 전체 서비스가 중단될 수 있습니다.
  
  - 또한 사용자 수가 늘어날수록 요청 처리에 대한 병목이 발생할 수 있으며, 확장성에도 한계가 있습니다.

  - 이를 해결하기 위해서는 서버를 여러 대로 확장하거나, 로드밸런서를 통해 트래픽을 분산하는 방법등이 있습니다.
  
  - 특히 동시성 제어와 관련하여, 현재는 ReentrantLock을 사용한 JVM 기반 락으로 처리를 하고 있지만, 다중 서버 환경에서는 이 방식이 동작하지 않기 때문에 Redis 기반의 분산 락으로 변경해야 합니다.

</details>

### 왜 Redis 분산락에서 JVM 락으로 바꿨나요?

<details>
  <summary>✅ 답변</summary>

  - 초기에는 Redis 기반 분산락을 사용했지만, 시스템 구조를 분석해보니 단일 서버 환경에서는 네트워크 기반의 락이 오히려 불필요하게 오버헤드를 유발할 수 있다고 판단했습니다.
  
  - Redis 락은 여러 서버 간 자원을 보호할 수 있는 장점이 있지만, 단일 프로세스, 단일 JVM 환경에서는 ReentrantLock 같은 JVM 레벨 락이 더 경량화되어 있고 성능적으로도 유리합니다.
  
  - 따라서 현재는 운영 환경에 맞게 과도한 분산 시스템 설계를 피하고, JVM 내부에서 충분히 동시성 제어가 가능하다고 판단하여 리팩토링하게 되었습니다.

</details>

### ReentrantLock 대신 Redis 분산 락을 선택해야 하는 상황은 어떤 경우인가요?

<details>
  <summary>✅ 답변</summary>

  - ReentrantLock은 JVM 내부 메모리에서만 동작하기 때문에, 단일 서버 환경에서는 유효하지만 다중 서버 환경에서는 각 서버가 서로 다른 JVM 인스턴스를 사용하므로 락이 공유되지 않습니다.

- 따라서 동일한 자원에 대한 동시 접근이 여러 서버에서 발생할 경우, ReentrantLock으로는 경쟁 조건을 방지할 수 없습니다.

- 이런 상황에서는 Redis 분산 락을 활용하여 모든 서버가 중앙의 Redis 인스턴스를 통해 락을 관리함으로써, 서버 간에도 일관된 동시성 제어가 가능해집니다.

- Redisson이나 Lettuce와 같은 라이브러리를 사용하면 분산 환경에서도 안전하게 락 획득 및 해제가 가능합니다.
  
</details>

### Redis TTL 이벤트를 활용한 경매 종료 처리 방식의 한계나 리스크는 없을까요?

<details>
  <summary>✅ 답변</summary>

  - Redis TTL 기반의 Key Expiration Event는 Redis 서버 설정에 따라 비활성화되어 있을 수 있고, Redis 장애 발생 시 해당 이벤트가 유실될 가능성이 있습니다.
  
  - 또한 TTL 이벤트는 정확한 시간 보장을 하지 않기 때문에, 경매 종료 시점을 초 단위로 정밀하게 처리해야 하는 경우에는 신뢰성이 떨어질 수 있습니다.
  
  - 이러한 리스크를 보완하기 위해, 백엔드에서 주기적으로 경매 종료 시간을 체크하는 스케줄링 로직을 도입하거나, 데이터베이스 기반의 시간 조건 쿼리를 통해 경매 상태를 갱신하는 방식도 고려할 수 있습니다.
    
</details>

---

## ✅ **2. Spring Boot & 비즈니스 로직**

### 상품 등록/입찰/낙찰 등 주요 도메인 로직은 어떻게 설계하셨나요?

<details>
  <summary>✅ 답변</summary>

  - 상품, 입찰, 주문(Order) 도메인을 중심으로 각 기능을 설계했습니다.

  - **상품 등록**은 인증된 사용자만 가능하며, 등록 시 경매 시작/종료 시간과 시작 가격, 즉시 구매가 등을 함께 설정합니다.
  
  - **입찰** 기능은 현재 시간 기준으로 경매가 진행 중이고, 해당 상품이 낙찰되지 않은 경우에만 가능합니다.  
    입찰 시 이전 최고 입찰자보다 높은 금액만 허용되며, 입찰 기록은 별도 엔티티로 저장됩니다.
  
  - **즉시 구매**는 해당 상품을 설정된 즉시 구매가로 즉시 낙찰 처리됩니다.
    이 때 상품 상태는 '낙찰 완료'로 변경되며, 해당 상품의 다른 입찰 정보는 모두 무효화되고 관련 주문은 취소됩니다.
  
  - **낙찰 처리**는 두 가지 방식으로 진행됩니다:  
    1) 즉시 구매 실행 시  
    2) 경매 종료 시간 도래 시 Redis TTL 이벤트나 스케줄링을 통해 자동 낙찰 처리됨
  
  - 낙찰 시 가장 높은 입찰자의 정보로 낙찰 주문을 생성하고, 이후 주문 결제나 배송 절차로 이어질 수 있도록 구조를 설계했습니다.

</details>

### 입찰 기능에서의 트랜잭션 처리 방식은 어떻게 되나요?

<details>
  <summary>✅ 답변</summary>

  - 입찰 기능은 동시성 이슈가 발생할 수 있는 핵심 로직이기 때문에, 트랜잭션과 락을 함께 활용해 처리했습니다.

  - 먼저, 입찰 요청이 들어오면 `@Transactional`이 선언된 서비스 메서드가 실행됩니다.
  
  - 이후 현재 상품의 경매 상태, 입찰 금액 유효성 검증, 새로운 입찰 정보 저장, 상품의 최고 입찰가 업데이트 등을 진행합니다.
  
  - 트랜잭션이 시작되기 전에, **JVM 기반의 `ReentrantLock`을 사용하여 상품 단위로 락을 획득**합니다.  

  - 이를 통해 동일한 상품에 대해 동시에 입찰하는 요청이 순차적으로 처리되도록 합니다.
  
  - 트랜잭션이 **정상적으로 커밋된 이후에만 락을 해제**합니다.
    
  - 이를 위해 `TransactionSynchronizationManager.registerSynchronization()`을 사용하여 트랜잭션 커밋 이후 락을 해제하는 콜백을 등록했습니다.

</details>

### 입찰 시 동시성 제어는 어떻게 구현하셨나요?

<details>
  <summary>✅ 답변</summary>

  - 현재 프로젝트는 단일 서버 환경에서 운영되고 있어, JVM 내에서 동작하는 `ReentrantLock`을 활용해 동시성 제어를 구현했습니다.  
  
  - 입찰 기능은 동시에 여러 사용자가 요청을 보낼 수 있는 민감한 구간이기 때문에, 낙관적 락보다는 충돌을 사전에 방지하는 비관적 락 전략이 적합하다고 판단했습니다.

  - 트랜잭션은 `@Transactional` 어노테이션을 통해 시작되며, 메서드 진입 시점에 `ReentrantLock`을 획득합니다.  
  
  - 초기에는 비즈니스 로직 수행 후 곧바로 락을 해제했는데, 이 경우 트랜잭션 커밋 이전에 락이 풀리면서 다른 요청이 동시에 접근하는 문제가 발생했습니다.

  - 이를 해결하기 위해 `TransactionSynchronizationManager`를 활용해 트랜잭션이 정상적으로 커밋된 이후에 락을 해제하도록 처리했습니다.  
  
  - 이 방식으로 동시성 문제를 안정적으로 제어할 수 있었고, 테스트 환경에서도 중복 낙찰이나 데이터 정합성 오류가 해결되었습니다.

</details>

### 꼬리 질문:

* 비관적 락, 낙관적 락, 분산 락과 비교했을 때 ReentrantLock의 장단점은 무엇인가요?
* 동시성 처리 시 고려해야 할 이슈들은 어떤 게 있었나요?
* 서비스 레이어에서 발생 가능한 Race Condition 외에 또 어떤 케이스가 있었나요?

>"TransactionSynchronizationManager를 사용한 이유는 무엇인가요? finally 블록에서 락 해제하면 안 되나요?"
→ 트랜잭션 커밋 전에 락을 해제하면 실제 DB 반영 전에 다른 스레드가 입찰을 시도해 충돌이 발생할 수 있음.

"트랜잭션 실패나 예외 발생 시 락은 어떻게 처리되나요?"
→ 예외 발생 시에도 안전하게 락을 해제할 수 있도록 롤백 시점에 대한 처리 필요.

"동시 입찰이 몰릴 경우, 성능 병목이나 데드락이 발생할 수 있는 구조 아닌가요?"
→ 병목 가능성 및 락을 사용하지 않고 처리할 수 있는 대안 (예: DB 낙관적 락, 버전 필드 사용 등)에 대해 물을 수 있음.

---

## ✅ **3. QueryDSL**

### 질문:

* QueryDSL을 사용한 이유는 무엇인가요?
* 검색 기능 구현 시 성능이나 유지보수 측면에서 어떤 장점이 있었나요?

### 꼬리 질문:

* QueryDSL 대신 JPA Criteria나 Specification을 사용할 수도 있는데 어떤 차이점이 있나요?
* 복잡한 검색 조건을 어떻게 동적으로 처리했나요?
* 페이징 처리 시 성능 이슈가 있었나요?

---

## ✅ **4. Redis & 인증 처리**

> 기존에 사용한 Redis를 통한 경매 종료 이벤트 리스너는 과엔지니어링이라 판단하여 Spring 스케줄러로 수정했습니다.


### Redis를 사용한 이유는 무엇인가요?

> "Redis를 그냥 쓴 게 아니라, 데이터 특성과 시스템 구조를 고려했을 때 가장 적절했기 때문에 썼다. 다른 방법도 고려해봤지만, 이런 이유로 배제했다."

<details>
  <summary>✅ 답변</summary>
  
  - 이메일 인증 코드는 보안적으로 민감하면서도 유효 시간이 짧기 때문에, TTL 기능이 있는 Redis에 저장하는 것이 더 적절하다고 판단했습니다.
  
  - in-memory 기반이라 빠르게 조회할 수 있고, TTL 설정을 통해 일정 시간이 지나면 자동으로 데이터를 제거해줘서 별도로 만료 처리를 하지 않아도 돼 효율적입니다.
  
  - 그리고 같은 이메일로 자주 인증 요청이 들어오면 이메일 서버에 과부하가 생길 수 있기 때문에, 마지막 요청 시간을 Redis에 저장하고 TTL을 1분으로 설정해 반복 요청을 막았습니다.
  
  - 단일 서버 기준으로는 꼭 Redis를 써야 할 이유는 없지만, 추후 수평 확장을 고려했을 때 세션이나 캐시, 인증 정보 같은 일시적인 데이터는 Redis를 통해 관리하는 게 더 유리하다고 생각했습니다.

  ###  면접관이 궁금해할 수 있는 부분들

  - 꼭 Redis여야 했나요?

    - Redis는 도입 비용이 있고 운영 복잡도도 생겨요.

  - 단일 서버 + 소규모 트래픽이라면, 그냥 RDB에 short TTL 필드 넣고 스케줄링 해도 되지 않았을까요?

  - DB에 저장했을 때의 단점은 뭐죠?

    - 예를 들어 인증코드 만료를 어떻게 관리할지, 불필요한 데이터가 남지 않게 하려면 어떤 로직이 필요할지

  - 어떻게 Redis TTL 만료 시점과 사용자 요청 타이밍 간 race condition을 방지했나요?

  - 만약 유저가 인증 코드를 입력하는 순간에 TTL 만료되면?
    
</details>

### 이메일 인증 기능은 어떤 구조로 동작하나요?

<details>
  <summary>✅ 답변</summary>
</details>

### 꼬리 질문:

### 인증 코드 TTL을 Redis에서 관리하는 이유는 무엇인가요?

<details>
  <summary>✅ 답변</summary>
</details>

### Redis 장애 시 어떤 방식으로 대처할 수 있을까요?

<details>
  <summary>✅ 답변</summary>
</details>
### Redis를 세션 저장소로도 사용할 수 있는데, 인증 코드 외에 어떻게 활용할 수 있나요?

---

## ✅ **5. JWT 기반 인증/인가**

### 질문:

* JWT 인증 흐름을 설명해 주세요.
* JWT 토큰의 유효성 검증은 어떤 방식으로 했나요?

### 꼬리 질문:

* JWT와 세션 기반 인증의 차이점은 무엇이라고 생각하나요?
* JWT에 어떤 정보를 담았으며, 보안상 어떻게 보호했나요?
* 리프레시 토큰은 구현하셨나요? 왜 또는 왜 안 했는지?

---

## ✅ **6. CI/CD with GitHub Actions**

### 질문:

* GitHub Actions로 어떤 자동화 작업을 했나요?
* CI/CD 파이프라인 구성을 설명해주세요.

### 꼬리 질문:

* `빌드 실패` 혹은 `배포 실패` 시 어떤 알림이나 롤백 전략이 있나요?
* 테스트는 어느 단계에서 진행되나요?
* CI/CD를 로컬에서 먼저 테스트해본 경험이 있나요?

---

## ✅ **7. Docker, Nginx, AWS EC2 배포**

### 질문:

* Docker Compose로 각 서비스를 어떻게 분리하고 구성했나요?
* Nginx는 어떤 역할을 하고 있나요?
* HTTPS 인증서는 어떻게 적용했나요?

### 꼬리 질문:

* Nginx의 리버스 프록시 설정은 어떻게 구성했나요?
* Let's Encrypt 인증서 갱신 자동화는 어떻게 했나요?
* EC2 단일 인스턴스에서 발생할 수 있는 문제점은?

---

## ✅ **8. 프론트엔드 (React)**

### 질문:

* 상품 등록/검색/입찰 UI는 어떤 방식으로 구현했나요?
* API 요청 구조 및 예외 처리 방식은 어떤 식으로 처리했나요?

### 꼬리 질문:

* REST API 호출 시 에러 핸들링은 어떻게 구성했나요?
* React Query 같은 데이터 패칭 라이브러리 사용 여부 및 이유는?
* 페이지네이션이나 무한 스크롤을 구현한 부분이 있나요?

---

## ✅ **9. 테스트 및 품질 관리**

### 질문:

* 어떤 테스트를 작성했나요? (단위/통합/인수)
* 테스트 자동화는 CI에 통합되었나요?

### 꼬리 질문:

* 입찰 로직 테스트에서 어떤 케이스들을 중점적으로 확인했나요?
* 테스트 커버리지를 높이기 위한 시도는 있었나요?

---

## ✅ **10. 성능/보안/운영 이슈**

### 질문:

* 이 프로젝트에서 보안적으로 신경 쓴 부분은 무엇인가요?
* 입찰과 같은 민감 로직에서 성능을 개선한 경험이 있나요?

### 꼬리 질문:

* HTTPS 설정을 통한 보안 외에 CSRF/XSS 등은 어떻게 대응했나요?
* DB 인덱싱, 캐싱 전략은 어떻게 고려했나요?

---

이 외에도 면접관은 이런 질문들을 기반으로 **"만약 실 서비스로 확장한다면?"** 이라는 방향의 질문도 자주 던집니다.
예:

* 트래픽이 많아지면 어떻게 확장할 건가요?
* 서버가 여러 개로 분산될 때 락 처리 방식은 어떻게 바뀌어야 하나요?
* 모놀리식 구조 vs 마이크로서비스로 전환 가능성에 대해 어떻게 생각하나요?

