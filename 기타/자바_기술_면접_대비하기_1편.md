[자바 기술 면접 대비하기 - 1편](https://f-lab.kr/blog/java-backend-interview-1) 해당 사이트를 참고하여 답에 대한 정리를 기록한 글입니다.

---

### 1. 자바의 모든 클래스는 **Object** 클래스를 상속받습니다. 그리고 **Object**클래스에는 **equals()** 와 **hashCode()** 라는 메소드가 선언되어 있습니다. 이 메소드들은 각각 어떤 역할일까요? 이 둘의 차이점은 무엇일까요?

<details>
  <summary>✅ 답변</summary>
  
  - **equals()** 는 두 객체가 논리적으로 같은지 비교하는 메소드입니다. 기본 구현은 객체의 참조값을 비교합니다.
  
  - **hashCode()** 는 객체를 해시 기반 컬렉션에 저장하거나 검색할 때 사용되는 정수 해시 코드를 반환합니다.
  
  - **equals()** 는 두 객체의 논리적 동등성을 비교하고, **hashCode()** 는 객체의 해시값을 반환해 해시 기반 자료구조에서 사용됩니다.   

</details>

### 2. "hashCode"를 오버라이드 했을 때 메모리 주소를 리턴하게 할 수 있을까요? 자바에서는 개발자가 직접 메모리에 접근할 수 있나요?

<details>
  <summary>✅ 답변</summary>
  
  - 자바는 메모리 관리와 주소 접근을 추상화하기 때문에, 개발자가 직접 객체의 메모리 주소를 얻거나, 그 주소를 해시값으로 반환하는 것은 불가능합니다.
  
</details>

### 3. "hashCode" 를 잘못 오버라이딩하면 "HashMap" 등 hash 콜렉션의 성능이 떨어질 수가 있습니다. 어떤 케이스일 때 그럴 수 있을까요? 

<details>
  <summary>✅ 답변</summary>

  - **모든 객체가 같은 hashCode 값을 반환하는 경우** 서로 다른 키들이 모두 동일한 버킷(배열 인덱스)에 저장되어,
  
  - 해당 버킷이 연결 리스트(혹은 Java 8 이상에서는 임계치 초과 시 레드-블랙 트리)로 길게 늘어납니다.   
  
  - 이 경우 HashMap의 탐색, 삽입, 삭제 연산이 평균 O(1)에서 최악 O(n)까지 떨어집니다. 

</details>

### 4."HashMap"은 내부적으로 어떻게 구현되어있길래 그렇게 빨리 값을 탐색할 수 있을까요?

<details>
  <summary>✅ 답변</summary>

  - HashMap은 **배열 기반의 해시 테이블 구조**를 사용해 키의 hashCode() 값을 바탕으로 배열 인덱스를 계산해, 해당 인덱스(버킷)에 key-value 쌍을 저장합니다.   
  
  - 동일 인덱스에 여러 키가 모이면 **연결 리스트**로 관리하다가, 한 버킷에 8개 이상의 노드가 쌓이면 **레드-블랙 트리**로 전환해 최악의 경우에도 O(log n) 성능을 보장합니다.  
  
  - 이러한 구조 덕분에 대부분의 탐색/삽입/삭제 연산이 O(1)에 가깝게 동작합니다.

</details>

### 5. 기존 "HashMap"의 시간복잡도는 얼마이고, "hashCode"를 잘못 오버라이딩 했을 때의 시간복잡도는 얼마일까요?

<details>
  <summary>✅ 답변</summary>
  
  - get, put, remove, containsKey 등의 연산이 **평균 O(1)**의 시간복잡도를 가집니다.   
  
  - 잘못 오버라이딩 했을 때는 모든 키가 한 버킷에 몰려 연결 리스트(혹은 트리)로 관리되므로
      - 연결 리스트인 경우: **최악 O(n)**  
      - 트리로 전환된 경우: **최악 O(log n)**  

</details>

---

### 1. StringBuilder와 StringBuffer의 차이는 무엇일까요?

<details>
  <summary>✅ 답변</summary>
  
  - StringBuilder와 StringBuffer는 모두 가변 문자열을 다루는 클래스인데 가장 큰 차이점은 **동기화(synchronization) 지원 여부**입니다.
  
  - **StringBuffer**는 내부 메서드에 `synchronized` 키워드를 사용해 멀티스레드 환경에서 안전하게 동작합니다.
    
  - **StringBuilder**는 동기화를 지원하지 않아 thread-safe하지 않지만, 그만큼 불필요한 락 오버헤드가 없어 단일 스레드 환경에서 더 빠른 성능을 보입니다.  

</details>

### 2. 왜 동기화(synchronized)가 걸려있으면 느린걸까요?

<details>
  <summary>✅ 답변</summary>
  
  - `synchronized` 키워드는 여러 스레드가 동시에 같은 자원에 접근하지 못하도록 락을 걸어줍니다.
  
  - 이 과정에서 JVM은 객체의 모니터 락을 획득·해제하고, 메모리 가시성 보장, 명령어 재배치 방지 등 여러 부가 작업을 수행합니다.  
  
  - 락 획득/해제, 커널 모드 전환, 캐시 플러시 등으로 인해 단일 스레드 환경에서도 락 관리에 따른 오버헤드가 발생해 성능이 저하됩니다.

</details>

### 3. 싱글 스레드로 접근한다는 가정하에선 StringBuilder와 StringBuffer의 성능이 똑같을까요?

<details>
  <summary>✅ 답변</summary>
  
  - 싱글 스레드 환경에서도 StringBuffer는 모든 메서드에 synchronized가 걸려 있어 락 획득/해제 오버헤드가 존재합니다.  
  
  - JVM의 최적화 덕분에 성능 차이가 크지 않을 수 있지만, 일반적으로 StringBuilder가 더 빠른 성능을 보입니다.

</details>

---

### 1. System.out.println 메소드는 현업에서 절대 쓰지 말라고 하는데, 그 이유가 무엇일까요?

<details>
  <summary>✅ 답변</summary>
  
  - System.out.println은 내부적으로 **synchronized**로 동기화되어 있고, 실제로 콘솔에 출력할 때 **Blocking IO**가 발생합니다.
  
  - 즉, 여러 스레드가 동시에 출력하면 락 경합이 일어나고, 각 스레드는 IO 작업이 끝날 때까지 대기(블로킹)하게 됩니다.

</details>

### 2. 왜 그것들이 성능을 저하시킬까요?

<details>
  <summary>✅ 답변</summary>
  
  - **synchronized**는 락을 획득/해제하는 오버헤드가 발생하고, 여러 스레드가 동시에 접근하면 락 경합으로 인해 대기 시간이 길어집니다.
    
  - **Blocking IO**는 IO 작업이 끝날 때까지 스레드가 아무 일도 못 하고 멈춰 있으므로, CPU 자원을 효율적으로 활용하지 못합니다.
    
  - 두 가지가 결합되면, 한 스레드가 락을 잡고 IO가 끝날 때까지 대기하는 동안 나머지 스레드도 모두 대기하게 되어, 전체 처리량이 급격히 떨어집니다.

</details>

### 3. synchronized 키워드는 왜 현업에서 큰 성능 저하를 일으킬 수 있을까요?

<details>
  <summary>✅ 답변</summary>
  
  - synchronized는 락 획득/해제, 메모리 동기화, 커널 모드 전환 등 부가적인 작업이 필요합니다.
  
  - 특히 여러 스레드가 동시에 락을 요청하면, 한 번에 하나의 스레드만 진입하고 나머지는 모두 대기해야 하므로, 락 경합이 심할수록 성능 저하가 커집니다.
  
  - 심지어 단일 스레드 환경에서도 락 관리 오버헤드로 인해 성능이 떨어질 수 있습니다.

</details>

### 4. Blocking IO는 왜 성능을 저하시킬 수 있을까요?

<details>
  <summary>✅ 답변</summary>
  
  - Blocking IO는 스레드가 IO 작업(예: 콘솔 출력, 파일 쓰기 등)이 끝날 때까지 완전히 멈춰 있게 만듭니다.  
  
  - 이 때문에 해당 스레드는 CPU를 활용하지 못하고, 대기 상태에 머물게 됩니다.  
  
  - 대량의 IO 작업이 있을 때는 많은 스레드가 동시에 블로킹되어 전체 시스템의 처리량이 감소합니다.

</details>

### 5. synchronized가 Blocking IO와 만나면 어떻게 환장의 성능하락을 만들 수 있을까요?

<details>
  <summary>✅ 답변</summary>
  
  - 두 가지가 결합되면, 한 스레드가 락을 잡고 Blocking IO를 수행하는 동안 나머지 모든 스레드는 락을 얻기 위해 대기 상태가 됩니다.
  
  - IO 작업이 끝나야만 락이 해제되고, 다음 스레드가 진입할 수 있습니다.
  
  - 즉, **여러 스레드가 있어도 한 번에 하나만 IO 작업을 하고, 나머지는 모두 멈춰 있게 되므로**  멀티스레드의 장점이 사라지고, 전체 처리량이 급격히 저하됩니다.

</details>

---

### 1. ArrayList는 내부적으로 어떻게 구현되어 있을까요?

<details>
  <summary>✅ 답변</summary>
  
  - ArrayList는 내부적으로 **동적 배열(Object[] 배열)**을 사용해 데이터를 저장합니다.  
  
  - 처음 생성 시에는 기본 크기(보통 10)의 배열이 할당되고, 요소가 추가될 때마다 배열의 크기와 현재 데이터 개수(size)를 비교해 관리합니다.  
  
  - 배열이 가득 차면, 더 큰 크기의 새로운 배열을 생성하고 기존 데이터를 모두 복사한 뒤 새로운 요소를 추가합니다.

</details>

---

### 1. 스레드는 왜 써야하는 것일까요?

<details>
  <summary>✅ 답변</summary>
  
  - 스레드는 하나의 프로세스 내에서 여러 작업을 동시에 처리할 수 있게 해줍니다.  
  
  - 스레드는 같은 메모리 공간을 공유하기 때문에 프로세스보다 자원 소모가 적고, 데이터 교환이 빠르며, 컨텍스트 스위칭 비용도 프로세스에 비해 훨씬 작아 효율적입니다.

</details>

### 2. 스레드를 쓰면 동시에 여러 일을 처리할 수 있으니 한 1만개 정도 띄우면 너무 좋지 않을까요?

<details>
  <summary>✅ 답변</summary>
  
  - 스레드를 많이 띄운다고 무조건 좋은 것은 아닙니다.  
  
  - 스레드마다 고유한 스택과 컨텍스트 정보를 가지기 때문에, 스레드가 많아질수록 **메모리 사용량이 급격히 늘고**
  
  - 운영체제는 각 스레드에 CPU를 분배하기 위해 **컨텍스트 스위칭**을 자주 하게 됩니다.
  
  - 이 과정에서 CPU 자원이 낭비되고, 실제 작업보다 스케줄링과 전환 비용이 더 커질 수 있습니다.
  
  - 또한, 동기화 비용, 락 경합, 디버깅 난이도 증가 등 부가적인 문제도 발생합니다.

  > 프로세스 vs 스레드 [우테코 테코톡](https://www.youtube.com/watch?v=1grtWKqTn50)

  ![image](https://github.com/user-attachments/assets/9d30472d-31c9-472c-917f-a6e008bccde2)

  
</details>

---

### 1. 0이 들어있는 변수에 10개의 스레드가 동시에 접근해서 ++ 연산을 하면 우리 예상과 다르게 10이 나오지 않습니다. 왜 그럴까요?

<details>
  <summary>✅ 답변</summary>
  
  - 이 현상은 **동시성 문제(경쟁 상태, Race Condition)** 때문입니다.
  
  - 여러 스레드가 동시에 같은 변수에 접근해 `++` 연산을 수행하면, 각 스레드가 변수 값을 읽고, 1을 더한 뒤, 다시 저장하는 과정이 겹치게됩니다.
  
  - 일부 증가 연산이 덮어써지거나 무시되므로 10번의 증가가 모두 반영되지 않고, 결과가 10보다 작게 나오는 것입니다.

</details>

### 2. ++ 연산은 구체적으로 어떤 행위들로 이루어져 있을까요?

<details>
  <summary>✅ 답변</summary>
  
  - ++ 연산은 사실상 아래와 같은 세 단계로 이루어집니다:
    1. **메모리에서 해당 값을 가져옵니다.** (load)
    2. **해당 값에 1을 더합니다.** (add)
    3. **메모리에 더한 값을 덮어씁니다.** (store)
  
  - 이 세 단계가 원자적으로(한 번에) 수행되지 않기 때문에, 여러 스레드가 동시에 접근하면 값이 꼬일 수 있습니다.

</details>

### 3. 이 문제를 해결하려면 어떻게 해야할까요?

<details>
  <summary>✅ 답변</summary>
  
  - 이 문제를 해결하려면 **동기화(synchronization)** 또는 **원자적 연산(atomic operation)**을 사용해야 합니다.

</details>

### 4. synchronized 키워드는 이 문제를 어떻게 해결하는걸까요?

<details>
  <summary>✅ 답변</summary>
  
  - `synchronized`는 한 번에 하나의 스레드만 임계영역(공유 변수 접근 코드)에 진입할 수 있게 해줍니다.  
  
  - 즉, 한 스레드가 ++ 연산을 모두 끝내기 전까지 다른 스레드는 대기하게 되어 세 단계(load, add, store)가 중간에 끊기지 않고 안전하게 수행됩니다.

</details>

---

### 1. 자바에서 동시성과 관련된 예약어는 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - **synchronized**
    
    - 한 번에 하나의 스레드만 특정 코드 블록이나 메서드에 진입할 수 있도록 락(lock)을 걸어, 공유 자원에 대한 동시 접근을 제어합니다.  
  
  - **volatile**
    
    - 변수 앞에 붙여 사용하는 키워드로, 해당 변수의 값을 **항상 메인 메모리에서 읽고 쓰도록 강제**합니다.
  
    - 이로써 여러 스레드가 해당 변수의 변경 사항을 즉시 볼 수 있게 하여 **가시성(visibility)**을 보장합니다.

</details>

### 2. volatile 키워드는 어떤 키워드일까요?

<details>
  <summary>✅ 답변</summary>
  
  - `volatile`은 변수의 값을 **CPU 캐시가 아닌 메인 메모리에서 직접 읽고 쓰도록** 컴파일러와 JVM에 지시하는 키워드입니다.  
  
  - 멀티스레드 환경에서 여러 스레드가 하나의 변수를 공유할 때, 한 스레드가 값을 변경하면 그 변경이 즉시 다른 스레드에도 반영되도록 보장합니다.

</details>

### 3. volatile의 "가시성"이란 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - 가시성이란 **여러 스레드가 공유 변수의 최신 값을 항상 동일하게 볼 수 있는 성질**을 의미합니다.  
  
  - CPU 캐시와 메인 메모리 사이의 동기화 문제로 인해 한 스레드가 변수 값을 바꿔도 다른 스레드가 이전 값을 읽는 문제를 해결할 수 있습니다.

</details>

### 4. volatile은 어떤 상황에 쓸 수 있을까요?

<details>
  <summary>✅ 답변</summary>
  
  - **상태 플래그, 종료 신호** 등 단순한 값을 여러 스레드가 공유할 때 사용합니다.
    
  - 예를 들어, 한 스레드가 `volatile boolean stop = false;`를 `true`로 바꿔서 다른 스레드에게 작업 중단을 알릴 때 적합합니다.
    
  - 단, ++ 연산과 같이 복합 연산의 원자성은 보장하지 않으므로 원자적 연산이 필요한 경우에는 `synchronized`나 `AtomicInteger` 등 다른 동기화 수단을 사용해야 합니다.

</details>

---

### 1. Blocking IO와 Non-Blocking IO 의 차이를 말씀해주세요.

<details>
  <summary>✅ 답변</summary>
  
  - **Blocking IO**는 프로그램(또는 스레드)이 IO 작업을 요청하면, 해당 작업이 끝날 때까지 프로그램이 멈추고 아무 일도 하지 못하는 방식입니다.
  
  - 즉, IO 함수 호출 시 커널이 작업을 완료할 때까지 제어권을 가져가고, 프로그램은 대기 상태가 됩니다.
  
  - **Non-Blocking IO**는 IO 작업을 요청해도, 함수가 즉시 리턴되어 프로그램이 멈추지 않고 계속 다른 작업을 할 수 있습니다.
  
  - IO가 아직 준비되지 않았다면 "아직 준비 안 됨"이라는 신호만 받고, 필요할 때마다 IO가 완료됐는지 확인하거나, 이벤트 기반으로 완료 알림을 받을 수 있습니다.
  
  | 구분           | Blocking IO                                | Non-Blocking IO                                   |
  |----------------|--------------------------------------------|---------------------------------------------------|
  | IO 호출 시     | IO 완료까지 스레드/프로세스가 대기(블록)    | 즉시 리턴, 스레드는 대기하지 않음                 |
  | 자원 활용      | 비효율적(대기 중 자원 낭비)                | 효율적(스레드가 다른 작업 수행 가능)              |
  | 동시성/확장성  | 낮음(스레드 1개당 요청 1개)                | 높음(적은 스레드로 많은 연결 처리 가능)           |
  | 구현 난이도    | 쉬움                                       | 상대적으로 복잡(이벤트, 상태 관리 등 필요)        |

</details>

### 2. Blocking IO가 일어나면 스레드에는 무슨 일이 생길까요?

<details>
  <summary>✅ 답변</summary>
  
  - 스레드는 IO 작업이 끝날 때까지 **Blocked(대기) 상태**로 전환되어, 아무 작업도 하지 못하고 멈춰 있게 됩니다.

</details>

### 3. 스레드가 멈춰있는 동안 CPU는 어떻게 될까요?

<details>
  <summary>✅ 답변</summary>
  
  - Blocked 상태의 스레드는 **CPU를 점유하지 않으며**, 운영체제는 다른 실행 가능한 스레드나 프로세스에 CPU를 할당합니다.  
  
  - 즉, Blocked 스레드는 CPU를 사용하지 않고 대기만 하게 됩니다.

</details>

### 3. CPU가 쉬는 것을 막으려면 어떻게 해야 할까요?

<details>
  <summary>✅ 답변</summary>
  
  - **Non-Blocking IO**를 사용해 스레드가 IO 대기 없이 계속 다른 작업을 하게 하거나,
    
  - **적절한 수의 스레드**를 사용해 IO 대기 중에도 다른 요청을 처리할 수 있도록 해야 합니다.
    
  - Non-Blocking IO는 적은 스레드로도 많은 작업을 동시에 처리할 수 있어, CPU가 효율적으로 활용됩니다.

</details>

### 4. 스레드를 늘리면 단점이 무엇일까요?

<details>
  <summary>✅ 답변</summary>
  
  - **메모리 사용량 증가**: 스레드마다 별도의 스택과 컨텍스트 정보가 필요해 메모리를 많이 소모합니다.
    
  - **컨텍스트 스위칭 오버헤드**: 스레드가 많아질수록 운영체제는 스레드 간 전환에 더 많은 CPU 시간을 소모하게 됩니다.
    
  - **락 경합 및 동기화 문제**: 공유 자원을 사용하는 스레드가 많아지면 락 경합이 심해지고, 데드락 위험도 커집니다.
    
  - **확장성 한계**: Blocking IO 기반 서버(Tomcat 등)는 스레드 1개당 요청 1개만 처리할 수 있어, 접속자가 많아지면 스레드 수가 급증하고 전체 성능이 저하됩니다.
  
  💡 **Tomcat이 스레드를 수백 개씩 띄우는 이유**  
  
  - Tomcat은 기본적으로 Blocking IO 방식을 사용하기 때문에, 요청 1개당 스레드 1개가 필요합니다.  
  
  - 접속자가 많아지면 스레드 수도 늘어나고, 이에 따른 오버헤드도 커집니다.

</details>

### 5. Non-Blocking IO는 CPU 활용률이 어떨까요?

<details>
  <summary>✅ 답변</summary>
  
  - Non-Blocking IO는 **적은 수의 스레드로도 많은 IO 작업을 동시에 처리할 수 있어 CPU 활용률이 매우 높습니다**.
  
  - 스레드가 IO 대기로 멈추지 않고, 계속해서 다른 작업을 처리할 수 있기 때문입니다.
  
  - Spring WebFlux, Netty 등은 Non-Blocking IO 기반으로 동작해, 대규모 동시 접속 환경에서도 높은 성능과 확장성을 제공합니다.

</details>

---

### 1. Serializable이란 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - **Serializable**은 자바에서 객체를 바이트 스트림으로 변환(직렬화)할 수 있음을 표시하는 **마커 인터페이스**입니다.
  
  - 이 인터페이스를 구현한 클래스의 객체는 파일로 저장하거나 네트워크를 통해 전송할 수 있습니다.

</details>

### 2. 직렬화란 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - **직렬화(Serialization)** 는 객체의 상태(필드 값 등)를 바이트 스트림으로 변환하는 과정입니다.
  
  - 이렇게 변환된 바이트 스트림은 파일로 저장하거나 네트워크를 통해 전송할 수 있습니다. 

</details>

### 3. 직렬화의 포맷에는 무엇이 있을까요?

<details>
  <summary>✅ 답변</summary>

  - **JSON**  
    - 사람이 읽기 쉽고, 다양한 언어와 환경에서 사용  
    - 웹 API, 데이터 교환 등에 널리 활용
  
  - **XML**  
    - 태그 기반의 구조로, 복잡한 데이터와 메타데이터 표현에 적합  
    - 시스템 간 데이터 교환, 문서 저장 등에 사용

</details>
 
