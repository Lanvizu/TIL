
## 📌 [기본 개념 관련 질문]

### 1. Redis는 어떤 종류의 저장소인가요?

<details>
  <summary>✅ 답변</summary>
  
  - Redis는 **인메모리** 기반의 Key-Value 저장소로, 데이터를 메모리에 저장하여 빠르게 읽고 쓸 수 있습니다.
  
  - 단순한 문자열뿐 아니라 리스트, 해시, 셋, 정렬된 셋 등 다양한 자료구조를 지원하며, TTL 설정, Pub/Sub, 트랜잭션, 스크립팅 등도 가능한 **NoSQL** 데이터베이스입니다.

  > 인메모리이지만 RDB나 AOF 설정으로 **디스크에 저장** 도 가능
  
  > 데이터베이스는 디스크 저장

</details>

### 2. Redis는 메모리 기반인데, 데이터가 많아지면 어떻게 되나요?

<details>
  <summary>✅ 답변</summary>
  
  - Redis는 메모리에 데이터를 저장하므로, 메모리 용량을 초과하면 성능 저하 또는 데이터 손실이 발생할 수 있습니다.
  
  - 이를 방지하기 위해 Redis는 maxmemory 설정을 제공하며, 초과 시 데이터를 제거하는 **eviction 정책(LRU, LFU 등)** 을 사용합니다.

  > 대용량 처리가 필요한 경우 Redis Cluster로 분산 저장도 가능
</details>


### 3. Redis의 장단점을 설명해 주세요.

<details>
  <summary>✅ 답변</summary>
  
  - **장점**은 **메모리 기반**이라 빠른 속도를 가지며 다양한 자료구조를 사용할 수 있습니다.

  - 또한 TTL을 지원하여 자동 만료 처리도 가능합니다.

  - **단점**은 메모리 기반(휘발성)이라 데이터 유실 가능성이 있습니다.

  - 디스크 기반 DB에 비해 저장 가능한 데이터량이 제한되며 CPU 사용에 한계가 존재합니다.
    
</details>


### 4. Redis는 싱글 스레드인데, 어떻게 빠른 성능을 낼 수 있을까요?

<details>
  <summary>✅ 답변</summary>
  
  - Redis는 명령을 단일 스레드로 순차적으로 처리합니다.
  
  - 하지만 메모리 기반이며, 내부 구조가 매우 최적화되어 있어 컨텍스트 스위칭, 락 경쟁 없이 매우 빠르게 처리됩니다.
  
  - 또한, **I/O Multiplexing (epoll 등)** 을 사용해 여러 클라이언트와 동시에 비동기 통신할 수 있습니다.

  > 싱글 쓰레드의 장점인 Atomic 연산 (race condition이 없음) -> 원자성 보장

  >  **I/O 멀티플렉싱**: 싱글 쓰레드가 여러 I/O 작업을 동시에 모니터링 할 수 있도록 해주는 기술

</details>

### 5. Redis의 TTL(Time-To-Live)은 어떤 방식으로 동작하나요?

<details>
  <summary>✅ 답변</summary>
  
  - Redis의 TTL은 key에 **유효 시간을 설정**하는 기능이며, 시간이 지나면 해당 key는 **자동으로 삭제**됩니다.

  1. Lazy deletion (지연 삭제): key 접근 시 만료되었으면 그 순간 삭제
  
  2. Active deletion (주기적 스캔): Redis가 백그라운드에서 만료된 키를 찾아 삭제

  > EXPIRE, SETEX, TTL 등의 명령어를 통해 TTL을 설정/조회 가능

</details>

### 6. Redis 데이터는 언제 휘발되나요?

<details>
  <summary>✅ 답변</summary>
  
  - 기본적으로 메모리 기반이기 때문에, **서버가 종료되거나 장애가 발생**하면 데이터가 휘발될 수 있습니다.

  - 이를 방지하기 위해 **RDB**나 **AOF** 설정을 통해 해결 가능합니다.
    
  > RDB (Snapshotting): 주기적으로 전체 데이터를 파일로 저장

  > AOF (Append Only File): 모든 쓰기 명령을 로그에 기록하여 복구 가능

</details>

---

## 📌 [이메일 인증 관련 - 캐시, TTL]

### 1. 왜 이메일 인증 코드를 Redis에 저장했나요? && DB 대신 Redis를 사용하는 이유는 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - 이메일 인증 코드는 **일시적인 데이터**이기 때문에, Redis의 TTL 기능을 통해 **자동 만료 및 삭제가 가능**하므로 적합하다고 생각했습니다.

  - 또한, 디스크 기반 DB보다 응답 속도가 빠르고 과부하도 줄일 수 있어 사용자 경험에도 효과적이라고 생각합니다.

  - RDB에 인증 코드 테이블을 만들고 직접 삭제 로직을 짜는 것보다 Redis를 이용해 **훨씬 간결하고 효율적인 방식으로 만료 처리가 가능**했습니다.

</details>

### 2. TTL은 어떻게 설정되며, 설정하지 않으면 어떻게 되나요?

<details>
  <summary>✅ 답변</summary>
  
  - Redis에서 TTL은 SET 명령어에 **만료 시간 옵션(EX, PX)** 을 함께 주거나, EXPIRE 명령어를 사용해 설정할 수 있습니다.
  
  - TTL을 설정하지 않으면, 해당 키는 영구적으로 저장되며 자동 삭제되지 않습니다.

  > 삭제되지 않으면 메모리 공간을 차지한다는 치명적인 단점이 존재

  > Java에서는 RedisTemplate.opsForValue().set(key, value, Duration.ofMillis(n)) 방식으로 TTL 설정

</details>

### 3. 인증 코드가 유효 시간 전에 삭제되거나 유실될 가능성은 없나요?

<details>
  <summary>✅ 답변</summary>
  
  - Redis는 기본적으로 메모리에 데이터를 저장하므로, 서버 장애나 종료 시 데이터 **유실 가능성이 존재**합니다.
  
  - 하지만 이메일 인증 코드는 중요도는 높지만 영구 보관이 필요 없는 단기 데이터입니다.
  
  - 일부 유실이 치명적이지 않으며 **TTL 만료를 통한 재발급**으로 쉽게 대응 가능합니다.
  
  > Redis가 메모리 한계를 초과한 경우 Eviction 정책에 따라 만료되지 않은 키도 삭제될 수 있으므로 주의가 필요

</details>

---

## 📌 [Rate Limiting (1분 제한)]

### 1. Rate Limit 처리를 Redis로 한 이유는 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - **Rate Limit**은 짧은 시간 동안의 **요청 횟수를 제한**해야 하는 기능으로, 이를 위해 **빠르고 TTL 제어가 가능**한 저장소가 필요합니다.
  
  - Redis는 메모리 기반으로 빠르고, EXPIRE 명령어를 통해 TTL 설정이 가능하여, 1분 동안 중복 요청을 방지하는데 최적화된 구조라고 생각합니다.

  > RDB는 초당 요청 처리 속도가 느려 실시간 제한에는 부적합하다고 판단

</details>

### 2. 동일 사용자가 반복 요청을 보낼 때, TTL 방식 외 다른 방법은 없었나요?

<details>
  <summary>✅ 답변</summary>
  
  - Redis의 **카운팅 기반 접근법**도 사용할 수 있습니다.
  
  - 예를 들어, INCR와 EXPIRE를 조합하여 사용자가 1분에 5번 이상 요청하면 차단하는 방식입니다.
  
  - 또는 Redis의 Sorted Set을 사용해 요청 타임스탬프를 기록하고 슬라이딩 윈도우 방식으로도 구현할 수 있습니다.

</details>

### 3. IP당 제한 같은 더 복잡한 제한도 구현 가능할까요? 어떻게?

<details>
  <summary>✅ 답변</summary>
  
  - Redis의 키 구조를 "rate:ip:{IP주소}"나 "rate:user:{userId}"처럼 구성하면 사용자나 IP 단위의 제한이 가능합니다.
  
  - 예를 들어 "rate:ip:192.168.0.1"이라는 키를 만들어 1분 동안 요청 횟수를 카운트하고, 정해진 횟수를 초과하면 차단할 수 있습니다.
  
  - 또는 Redis Lua 스크립트를 이용해 멀티 키 연산과 atomic 처리도 가능합니다.

</details>


### 4. TTL 갱신 방식은 어떤 방식인가요? sliding window vs fixed window?

<details>
  <summary>✅ 답변</summary>
  
  - 현재 구조는 **Fixed Window** 방식에 가깝습니다.

  - setLastSentTime()에서 키를 1분 동안 유지시키므로, 처음 요청 시점을 기준으로 1분 동안은 동일 요청을 차단합니다.
  
  - 즉, 일정 시간 동안 1회만 허용하는 방식이고, TTL이 지나면 다시 허용합니다.

  > Fixed Window: 정해진 간격(예: 1분)에 대해 고정된 제한

  > Sliding Window: 최근 N초 동안의 요청 수를 기준으로 판단 (예: 과거 60초간 5회 요청) -> 주로 Sorted Set 구조 사용

</details>

---

>  ReentrantLock으로 변경하여 해당 Redis 분산락은 삭제했습니다.

## 📌 [분산 락 관련]

### 1. 분산 락이 필요한 이유는 무엇인가요?

<details>
  <summary>✅ 답변</summary>
  
  - 분산 시스템에서는 여러 서버 인스턴스가 동시에 동일한 자원(예: 하나의 상품, 주문, 재고 등)에 접근할 수 있습니다.
  
  - 이때 동시성 충돌이나 중복 처리 문제를 방지하기 위해 분산 락이 필요합니다.
  
  - 예를 들어 경매에서 동시에 입찰하거나, 상품을 동시에 구매할 경우 데이터 무결성을 보장해야 하므로 분산 락을 사용해 한 시점에 하나의 요청만 처리되도록 합니다.

</details>

---

### 📌 \[경매 만료 TTL 처리 관련]

1. **경매 종료를 Redis TTL로 처리한 이유는 무엇인가요?**
2. **Redis TTL과 Spring Scheduler의 차이점은 무엇인가요?**
3. **Listener는 어떤 방식으로 구현되었나요? (ex. Redis keyspace notification?)**
4. **Redis TTL 이벤트가 누락되면 어떻게 하나요? (ex. Redis 다운 시?)**
5. **경매 시간이 변경되었을 경우 TTL은 어떻게 갱신되나요?**

---

### 📌 \[운영/아키텍처 관련 질문]

1. **Redis가 다운되면 어떤 데이터가 사라지나요?**
2. **Redis와 DB 간 데이터 불일치가 발생하면 어떻게 처리하나요?**
3. **Redis의 persistence 방식은 어떤 것이 있나요? RDB vs AOF의 차이점은?**
4. **Redis에 저장한 인증/락 데이터의 모니터링이나 추적은 어떻게 하나요?**
5. **Redis에 대한 장애 대비책은 마련되어 있나요? (Master-Slave, Sentinel, Cluster 등)**

---

### 📌 \[보너스: 실제로 나올 수 있는 꼬리 질문들]

* “캐시 무효화 전략은 어떤 걸 쓰셨나요?”
* “락을 획득했는데 처리 중 예외가 발생하면 어떻게 되나요?”
* “setIfAbsent 말고 Lua 스크립트를 사용해서 락을 구현할 수도 있는데 아시나요?”
* “Redis keyspace notification은 어떤 상황에서 유용한가요?”

---

### ✅ 팁: 모르면 어떻게 대답해야 할까?

모르는 질문이 나왔을 때는 솔직하게:

> "해당 부분은 아직 도입하지 않았지만, Redis에서 TTL 이벤트를 활용한 Keyspace Notification 기능이 있다는 걸 최근에 알게 되었고, 관련 자료를 찾아보는 중입니다."


