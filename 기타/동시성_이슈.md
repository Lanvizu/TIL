# 동시성 이슈에 대한 고민

OUA 프로젝트 설계 과정에서 동시성 문제에 대한 고민이 발생했다.

### 요구 사항

등록된 상품에 대한 유저들이 입찰을 진행한다.
입찰이 등록되면 상품의 입찰 최고가가 업데이트되며 다른 유저는 해당 가격 보다 높은 가격으로 입찰을 진행한다.
추가로 본인의 입찰을 취소할 수 있으며 최고 입찰가인 경우 업데이트된다.


## 1. 락을 사용하지 않은 경우

락을 적용하지 않으면, 여러 사용자가 동시에 같은 가격으로 입찰이 가능하다.
예를 들어, 유저 2와 유저 3이 거의 동시에 동일한 가격으로 입찰을 시도하면, 두 입찰 모두 데이터베이스에 반영된다.
즉, 동시성 이슈가 발생한다.


## 2. 낙관 락

- 낙관적 락(Optimistic Lock)은 product 테이블에 version 컬럼을 추가하여, 데이터의 변경 이력을 관리하는 방식

- 입찰 시점에 현재 version 값을 확인하고, 트랜잭션이 완료될 때 다시 한 번 version 값이 변경되었는지 체크한다.

- 만약 트랜잭션 도중 다른 사용자가 데이터를 수정하여 version 값이 바뀌었다면, 해당 트랜잭션은 롤백되고 재시도(retry) 정책에 따라 다시 실행된다.

- 이때, 재시도 로직은 별도로 구현해야 하며, 재시도 실패에 대한 처리도 필요하다.

- 낙관 락은 요청이 많지 않은 환경에서는 효율적일 수 있지만, 동시에 많은 사용자가 입찰하는 상황에서는 롤백과 재시도가 반복되어 서버에 큰 부하가 발생 가능하다.

결과적으로 입찰 요청이 급증하면 성능 저하가 심각해지고, 코드의 복잡성도 증가한다.

즉, 경매에 많은 사용자가 참여하는 상황에서는 낙관 락 방식이 적합하지 않다고 판단했다.

## 3. 비관 락

DB에 실질적인 락을 거는 방법으로 유저2의 입찰 등록 시 유저 3은 해당 상품에 입찰 등록에 접근할 수 없다.
유저2의 입찰 등록이 끝나면 그제서야 유저 3이 상품 입찰에 접근할 수 있게된다.

낙관적 락과 달리 락을 획들할 때 까지 block이 되므로 재시도하는 요청만큼 부하를 받을 필요가 없다는 점에서 더 적합한 방법이라고 생각한다.

또한, 비관적 락은 데이터베이스에 락을 설정하고 관리하기 때문에, 동시성이 높은 환경에서는 데이터베이스의 성능이 크게 저하될 수 있다.
만약 분산 시스템으로 구축되었다면 여러 애플리케이션이 동시에 DB에 접근하기 때문에, DB 락으로 인해 병목 현상이 발생할 수 있다.


4. Lettuce 분산 락 (SETNX)

일명 스핀 락으로 Redis의 Lettuce를 활용하는 기법이다.
Redis의 SET key value NX PX 명령어를 통해 락을 생성한다.
NX 옵션으로 이미 존재하는 키에 대한 중복을 방지하고, PX로 TTL을 설정한다.

락 해제 시, 소유권을 해체하여 자신이 생성한 락만 해제하도록 한다.

DEL 명령어로 락을 삭제하여 다른 클라이언트가 사용할 수 있도록 해준다.

이를 적용하면, 유저 2가 입찰을 등록하면 redis에 SETNX를 통해 유저 2에 대한 락을 설정한다.

이때 유저 3이 접근하면 redis에서 key를 획득할 때 까지 redis에 요청을 진행하게 된다.

이 후 유저 2의 트랜잭션이 종료되면 생성한 락을 삭제하여 유저 3이 접근할 수 있게된다.

낙관 락과 비관 락에 비하면 DB 직접적인 락을 사용하지 않아 서버 부하가 크지 않다는 장점이 있다.
그리고 비관 락에서 발생하는 병복 현상 데드 락이 발생할 확률을 현저하게 줄여준다.


5. Redission 분산 락 (Message Broker)

Redission Pub/Sub 방식을 이용하여 분산 락을 구현한다.
락을 획득하지 못한 경우 락에 대한 신호를 subscribe 하고 Block 상태로 대기하다가, 락이 해제되면 신호를 받고 락 획득을 다시 시도한다.

유저 2가 입찰UA 프로젝트 설계 과정에서 고민이 발생
동시성 이슈.
유저1이 상품을 등록한 후 다른 유저2와 3이 동시에 입찰을 진행 시 동시성 이슈가 발생한다.
해당 상황에서 동시성 문제를 해결하기 위한 고민을 정리하기 위해 글을 작성한다.

1. 락을 사용하지 않은 경우

상품에 대한 입찰이 동시에 이루어져 동시성 문제가 발생한다.
즉 유저 2와 3이 둘 다 동일한 가격으로 등록하게 되어 추후, 낙찰 과정에서 문제가 발생한다.


2. 낙관 락

product에 version 컬럼을 추가하여 버전을 관리하는 방법으로 유저 2가 주문을 진행하여 완료된 시점(transactional) 에서 product의 version을 비교하여 변화를 체크한다.
만약 변화가 있는 경우 롤백을 진행 후 다시 retry 정책을 따라 재 실행된다.
여기서 retry는 따로 설정해줘야한다.

이 경우 요청이 많지 않은 경우에 적합한 선택이지만 요청이 몰릴 경우 매 요청들이 다시 롤백되며 처리에 많은 시간이 걸리게 된다.
따라서 혹시라도 경매에 많은 사람들의 요청이 들어올 경우를 생각하여 해당 방법은 적합하지 않다고 판단했다.

**따라서 서버는 재시도하는 요청만큼 부하를 받게 되므로, 입찰의 수가 늘어나면 엄청난 성능 저하를 일으킬 수 있다.** 
**또한 이렇게 동작하기 위해서는 재시도에 대한 처리와, 재시도 실패에 대한 처리도 구현해야 하기 때문에 코드의 복잡성이 증가할 수 있다.**

3. 비관 락


DB에 실질적인 락을 거는 방법으로 유저2의 입찰 등록 시 유저 3은 해당 상품에 입찰 등록에 접근할 수 없다.
유저2의 입찰 등록이 끝나면 그제서야 유저 3이 상품 입찰에 접근할 수 있게된다.

낙관적 락과 달리 락을 획들할 때 까지 block이 되므로 재시도하는 요청만큼 부하를 받을 필요가 없다는 점에서 더 적합한 방법이라고 생각한다.

또한, 비관적 락은 데이터베이스에 락을 설정하고 관리하기 때문에, 동시성이 높은 환경에서는 데이터베이스의 성능이 크게 저하될 수 있다.
만약 분산 시스템으로 구축되었다면 여러 애플리케이션이 동시에 DB에 접근하기 때문에, DB 락으로 인해 병목 현상이 발생할 수 있다.


4. Lettuce 분산 락 (SETNX)

일명 스핀 락으로 Redis의 Lettuce를 활용하는 기법이다.
Redis의 SET key value NX PX 명령어를 통해 락을 생성한다.
NX 옵션으로 이미 존재하는 키에 대한 중복을 방지하고, PX로 TTL을 설정한다.

락 해제 시, 소유권을 해체하여 자신이 생성한 락만 해제하도록 한다.

DEL 명령어로 락을 삭제하여 다른 클라이언트가 사용할 수 있도록 해준다.

이를 적용하면, 유저 2가 입찰을 등록하면 redis에 SETNX를 통해 유저 2에 대한 락을 설정한다.

이때 유저 3이 접근하면 redis에서 key를 획득할 때 까지 redis에 요청을 진행하게 된다.

이 후 유저 2의 트랜잭션이 종료되면 생성한 락을 삭제하여 유저 3이 접근할 수 있게된다.

낙관 락과 비관 락에 비하면 DB 직접적인 락을 사용하지 않아 서버 부하가 크지 않다는 장점이 있다.
그리고 비관 락에서 발생하는 병복 현상 데드 락이 발생할 확률을 현저하게 줄여준다.


5. Redission 분산 락 (Message Broker)

Redission Pub/Sub 방식을 이용하여 분산 락을 구현한다.
락을 획득하지 못한 경우 락에 대한 신호를 subscribe 하고 Block 상태로 대기하다가, 락이 해제되면 신호를 받고 락 획득을 다시 시도한다.

유저 2가 입찰을 진행 중일 때 유저 3도 입찰을 진행하게되면 락을 획득하지 못해 락에 대한 신호를 구독하고 대기한다.
이후 유저 2의 입찰이 종료되면, 락에 대한 신호를 전송하고 이를 유저 3에게 전달되면 락 획득을 다시 시도한다.

Redission 분산 락을 이용하면 Lettuce 분산 락을 이용하는 방법에 비해 WAS에 부담이 적다는 장점이 있다.
Pub/Sub 메커니즘을 이용한 방법이므로 단일 Redis 인스턴스에 의존하므로 메시징 지연이나 네트워크로 인해 동기화되지 않을 수 있다.

master 노드가 다운되면 락 관리 불가능
락 획득 중 Master-Slave 간 데이터 복제가 지연되면, 노드 간 데이터 불일치 발생
