# 동시성 이슈에 대한 고민

OUA 프로젝트 설계 과정에서 동시성 문제에 대한 고민이 발생했다.

### 고민 사항

1. 등록된 상품에 대한 유저들이 입찰을 진행한다.

2. 입찰이 등록되면 상품의 입찰 최고가가 업데이트된다.

3. 다른 유저는 해당 가격 보다 높은 가격으로 입찰을 진행한다.

4. 추가로 본인의 입찰을 취소할 수 있으며 최고 입찰가인 경우 업데이트된다.

---

## 1. 락을 사용하지 않은 경우

- 락을 적용하지 않으면, 여러 사용자가 동시에 같은 가격으로 입찰이 가능하다.

- 예를 들어, 유저 2와 유저 3이 거의 동시에 동일한 가격으로 입찰을 시도하면, 두 입찰 모두 데이터베이스에 반영된다.

- 즉, 동시성 이슈가 발생한다.

---

## 2. 낙관적 락(Optimistic Lock)

> product 테이블에 version 컬럼을 추가하여, 데이터의 변경 이력을 관리하는 방식

1. 입찰 시점에 현재 version 값을 확인하고, 트랜잭션이 완료될 때 다시 한 번 version 값이 변경되었는지 체크한다.

2. 만약 트랜잭션 도중 다른 사용자가 데이터를 수정하여 version 값이 바뀌었다면, 해당 트랜잭션은 롤백되고 retry 정책에 따라 다시 실행된다.

    - 이때, 재시도 로직은 별도로 구현해야 하며, 재시도 실패에 대한 처리도 필요하다.

- 낙관 락은 요청이 많지 않은 환경에서는 효율적일 수 있지만, 동시에 많은 사용자가 입찰하는 상황에서는 롤백과 재시도가 반복되어 서버에 큰 부하가 발생 가능하다.

- 결과적으로 입찰 요청이 급증하면 성능 저하가 심각해지고, 코드의 복잡성도 증가한다.

**즉, 경매에 많은 사용자가 참여하는 상황에서는 낙관 락 방식이 적합하지 않다고 판단했다.**

---

## 3. 비관적 락(Pessimistic Lock)

> 데이터베이스 레벨에서 배타적 락을 사용하여 동시 접근을 제어하는 방식

1. 유저 2가 입찰을 시작하면 해당 상품에 대한 락을 선점하며, 유저 3은 유저 2의 트랜잭션이 완료될 때까지 **대기 상태**가 된다.

2. 락을 획득한 트랜잭션만 데이터 수정이 가능하며, 다른 트랜잭션은 락 해제 시까지 접근이 차단된다.

    - 낙관적 락과 달리 재시도 로직이 필요 없어 코드 복잡성이 감소한다.
      
    - 락 획득 실패 시 즉시 오류를 반환하므로 불필요한 재시도 부하가 발생하지 않는다.

- 단일 데이터베이스 환경에서는 직관적인 동시성 제어가 가능
  
- **동시성이 높은 환경** 에서는 데이터베이스 성능이 크게 저하될 수 있다.
  
- 분산 시스템의 경우 여러 애플리케이션이 동시에 DB에 접근하면 락으로 인한 **병목 현상** 이 발생할 수 있다.

**즉, 대규모 경매 서비스처럼 확장성이 중요한 시나리오에서는 비관적 락 방식이 적합하지 않다고 판단했다.**

---

## 4. SETNX 기반 커스텀 Redis 분산 락 (Lettuce 클라이언트를 활용하여 구현)

> Redis의 SETNX 명령어를 활용한 분산 락 구현

1. **락 획득**  

   - `SETNX`(SET if Not eXists) 명령어를 사용하여 특정 키에 값이 없을 때만 값을 설정
     
   - `NX` 옵션으로 이미 존재하는 키에 대한 중복을 방지하고, `PX` 옵션으로 TTL을 설정하여 데드락을 방지 가능

2. **락 점유 및 대기**  

   - 유저 2가 입찰을 등록하면 해당 상품에 대한 락을 Redis에 설정 

   - 유저 3이 같은 상품에 입찰을 시도하면, 락이 해제될 때까지 Redis에 반복적으로 락 획득 요청을 보내며 대기

   - 락 획득 시까지 재시도 로직을 개발자가 직접 구현해야 하며, 과도한 요청은 Redis에 부하를 줄 수 있으므로 적절한 지연 처리가 필요

3. **락 해제**  

   - 트랜잭션이 종료되면, 락을 생성한 클라이언트만 자신의 락을 해제하도록 구현

   - 락 해제는 `DEL` 명령어로 키를 삭제하여 다른 클라이언트가 락을 획득 가능하게 해줌

- DB에 직접 락을 걸지 않으므로 서버 부하가 적고, 빠른 성능과 확장성

- 병목 현상이나 데드락 발생 가능성을 감소

- Spin Lock 방식이므로 요청이 많을 경우 Redis에 부하 집중

- 락 해제 시 반드시 소유권을 검증하여, 자신이 생성한 락만 해제해야 함

- 락 획득 재시도 로직과, 타임아웃 등 예외 상황 처리가 필요


~~빠른 성능과 확장성이 필요한 환경에서 효과적으로 현재 프로젝트에 적합하다고 생각한다.~~

**단일 서버에서는 JVM 수준의 락(synchronized, ReentrantLock)으로도 충분하며, Redis 분산락은 오히려 오버엔지니어링**

---

## 5. Redission 분산 락 (Message Broker)

> Redis의 Pub/Sub 메커니즘을 활용한 분산 락 구현 방식

**진행 과정**

   - 락 획득에 실패한 클라이언트는 해당 락의 해제 신호를 **subscribe** 하고 blocking 상태로 대기

   - 락이 해제되면 **publish** 를 받고 즉시 재시도하여 락을 획득 

   - 유저 2가 입찰을 진행 중일 때, 유저 3이 동일한 상품에 입청 시도 → 락 획득 실패 → 락 해제 신호 구독 상태로 전환  

   - 유저 2의 입찰 완료 후 락 해제 신호 발행 → 유저 3이 신호 수신 → 즉시 락 획득 재시도

- Lettuce의 스핀 락 방식보다 **WAS 부하 감소**  

- 블로킹 대기 방식으로 네트워크 및 Redis 부하 최소화  

- 락 해제 시 즉각적인 재시도 가능

**단점 및 주의사항**  
   
   - 단일 Redis 인스턴스에 의존 → 메시지 전달 지연 시 동기화 문제 발생 가능  
   
   - **마스터 노드 장애** 시 락 관리 불가능  
   
   - Master-Slave 복제 지연 시 노드 간 데이터 불일치 발생 위험  
   
   - Redis 클러스터 구성 시 추가적인 설정 필요

**Pub/Sub 기반의 Redission 분산 락은 Lettuce 대비 WAS 부하를 줄일 수 있지만, Redis 인프라의 가용성과 복제 지연 문제를 고려해야 함**

---

## 6. JVM 기반 락 (synchronized / ReentrantLock)

> 단일 서버 환경에서의 동시성 제어를 위한 가장 단순하고 효과적인 방법

- 현재 프로젝트는 단일 WAS에서만 동작하기 때문에, 굳이 외부 시스템(Redis 등)을 활용한 분산 락을 구현하지 않아도 충분하다.

- Java에서는 JVM 수준의 락을 통해도 동시성 제어가 가능하다.

### 6-1. synchronized

- Java 기본 문법을 활용한 간단한 락 구현 방식
  
- 특정 메서드나 블록에 synchronized 키워드를 붙이면, 해당 코드 블록에 여러 스레드가 동시에 접근하지 못하게 막아줌
  
- 사용이 간편하고 안정적이나, 락 해제 시점을 명확하게 제어하기 어렵고 블로킹 해제가 불가능

### 6-2. ReentrantLock

- java.util.concurrent.locks.ReentrantLock 을 사용해 명시적으로 락을 걸고 해제할 수 있음

- 락 획득에 대한 타임아웃, 인터럽트, 조건 변수 등 다양한 제어 가능

- 예외 발생 시에도 finally 블록에서 반드시 unlock 해줘야 함

- ConcurrentHashMap을 활용해 상품 단위로 세분화된 락 관리 가능

### 장점

- Redis나 DB에 부하를 주지 않음

- 단일 서버에서 충분한 수준의 동시성 제어 제공

- 성능이 뛰어나며 구현이 간단

**❗️주의사항**

- 메모리 누수를 막기 위해 사용이 끝난 락은 주기적으로 정리해야 함

- 락이 과도하게 많아지지 않도록 제한적 관리 필요

✅ 결론

현재처럼 단일 서버 기반이고 트래픽이 폭주하지 않는 환경에서는 JVM 기반 락만으로 충분히 동시성 제어가 가능하다.

확장성을 고려하지 않는다면 Redis를 사용하는 것은 불필요하게 복잡하고 리스크가 크다.

---

# 결론

1. 락 미사용

    - 동시성 문제 발생

2. 낙관적 락

    - 트래픽이 적을 때는 효율적이지만, 많은 입찰이 동시에 시도되면 롤백/재시도로 인한 성능 저하로 부적합하다고 판단

3. 비관적 락

    - DB 차원의 배타 락을 통해 정확한 제어가 가능하나, DB 부하 및 데드락 가능성이 존재해 확장성 측면에서 비효율적

4. Redis 기반 분산 락 (Lettuce / Redisson)

    - 분산 시스템에서는 효과적이지만, 현재 단일 서버 환경에서는 과도한 설계이며, Redis 의존성과 관리 부담이 존재

5. JVM 기반 락 (synchronized / ReentrantLock)

    - 현재 프로젝트의 구조(단일 서버, 낮은 트래픽)에서는 가장 적합한 방식

    - 빠른 구현, 낮은 복잡도, 외부 의존성 없음

    - 상품 단위로 락을 분리하면 충분한 수준의 동시성 제어 가능

## 최종 선택

✅ **현재 구조에서는 JVM 레벨의 `ReentrantLock`을 사용한 상품 단위 락 관리가 가장 효율적이며 안정적인 선택이라고 판단**

단, 향후 서버가 수평 확장되거나 MSA 구조로 전환되는 경우, Redis 기반의 분산 락으로 전환을 고려 가능

---
### 참고

https://github.com/m020202/LiveTicketing

https://hudi.blog/distributed-lock-with-redis/

https://tech.kakaopay.com/post/troubleshooting-logs-as-a-junior-developer/
