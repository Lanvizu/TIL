# 동시성 이슈에 대한 고민

OUA 프로젝트 설계 과정에서 동시성 문제에 대한 고민이 발생했다.

### 고민 사항

1. 등록된 상품에 대한 유저들이 입찰을 진행한다.

2. 입찰이 등록되면 상품의 입찰 최고가가 업데이트된다.

3. 다른 유저는 해당 가격 보다 높은 가격으로 입찰을 진행한다.

4. 추가로 본인의 입찰을 취소할 수 있으며 최고 입찰가인 경우 업데이트된다.

---

## 1. 락을 사용하지 않은 경우

- 락을 적용하지 않으면, 여러 사용자가 동시에 같은 가격으로 입찰이 가능하다.

- 예를 들어, 유저 2와 유저 3이 거의 동시에 동일한 가격으로 입찰을 시도하면, 두 입찰 모두 데이터베이스에 반영된다.

- 즉, 동시성 이슈가 발생한다.

---

## 2. 낙관적 락(Optimistic Lock)

> product 테이블에 version 컬럼을 추가하여, 데이터의 변경 이력을 관리하는 방식

1. 입찰 시점에 현재 version 값을 확인하고, 트랜잭션이 완료될 때 다시 한 번 version 값이 변경되었는지 체크한다.

2. 만약 트랜잭션 도중 다른 사용자가 데이터를 수정하여 version 값이 바뀌었다면, 해당 트랜잭션은 롤백되고 retry 정책에 따라 다시 실행된다.

    - 이때, 재시도 로직은 별도로 구현해야 하며, 재시도 실패에 대한 처리도 필요하다.

- 낙관 락은 요청이 많지 않은 환경에서는 효율적일 수 있지만, 동시에 많은 사용자가 입찰하는 상황에서는 롤백과 재시도가 반복되어 서버에 큰 부하가 발생 가능하다.

- 결과적으로 입찰 요청이 급증하면 성능 저하가 심각해지고, 코드의 복잡성도 증가한다.

**즉, 경매에 많은 사용자가 참여하는 상황에서는 낙관 락 방식이 적합하지 않다고 판단했다.**

---

## 3. 비관적 락(Pessimistic Lock)

> 데이터베이스 레벨에서 배타적 락을 사용하여 동시 접근을 제어하는 방식

1. 유저 2가 입찰을 시작하면 해당 상품에 대한 락을 선점하며, 유저 3은 유저 2의 트랜잭션이 완료될 때까지 **대기 상태**가 된다.

2. 락을 획득한 트랜잭션만 데이터 수정이 가능하며, 다른 트랜잭션은 락 해제 시까지 접근이 차단된다.

    - 낙관적 락과 달리 재시도 로직이 필요 없어 코드 복잡성이 감소한다.
      
    - 락 획득 실패 시 즉시 오류를 반환하므로 불필요한 재시도 부하가 발생하지 않는다.

- 단일 데이터베이스 환경에서는 직관적인 동시성 제어가 가능
  
- **동시성이 높은 환경** 에서는 데이터베이스 성능이 크게 저하될 수 있다.
  
- 분산 시스템의 경우 여러 애플리케이션이 동시에 DB에 접근하면 락으로 인한 **병목 현상** 이 발생할 수 있다.

**즉, 대규모 경매 서비스처럼 확장성이 중요한 시나리오에서는 비관적 락 방식이 적합하지 않다고 판단했다.**

---

## 4. Lettuce 분산 락 (SETNX)

> Redis의 SETNX 명령어를 활용한 스핀 락 방식의 분산 락 구현

1. **락 획득**  

   - `SETNX`(SET if Not eXists) 명령어를 사용하여 특정 키에 값이 없을 때만 값을 설정
     
   - `NX` 옵션으로 이미 존재하는 키에 대한 중복을 방지하고, `PX` 옵션으로 TTL을 설정하여 데드락을 방지 가능

2. **락 점유 및 대기**  

   - 유저 2가 입찰을 등록하면 해당 상품에 대한 락을 Redis에 설정 

   - 유저 3이 같은 상품에 입찰을 시도하면, 락이 해제될 때까지 Redis에 반복적으로 락 획득 요청을 보내며 대기

   - 락 획득 시까지 재시도 로직을 개발자가 직접 구현해야 하며, 과도한 요청은 Redis에 부하를 줄 수 있으므로 적절한 지연 처리가 필요

3. **락 해제**  

   - 트랜잭션이 종료되면, 락을 생성한 클라이언트만 자신의 락을 해제하도록 구현

   - 락 해제는 `DEL` 명령어로 키를 삭제하여 다른 클라이언트가 락을 획득 가능하게 해줌

- DB에 직접 락을 걸지 않으므로 서버 부하가 적고, 빠른 성능과 확장성

- 병목 현상이나 데드락 발생 가능성을 감소

- Spin Lock 방식이므로 요청이 많을 경우 Redis에 부하 집중

- 락 해제 시 반드시 소유권을 검증하여, 자신이 생성한 락만 해제해야 함

- 락 획득 재시도 로직과, 타임아웃 등 예외 상황 처리가 필요

**빠른 성능과 확장성이 필요한 환경에서 효과적으로 현재 프로젝트에 적합하다고 생각한다.**

---

## 5. Redission 분산 락 (Message Broker)

> Redis의 Pub/Sub 메커니즘을 활용한 분산 락 구현 방식

**진행 과정**

   - 락 획득에 실패한 클라이언트는 해당 락의 해제 신호를 **subscribe** 하고 blocking 상태로 대기

   - 락이 해제되면 **publish** 를 받고 즉시 재시도하여 락을 획득 

   - 유저 2가 입찰을 진행 중일 때, 유저 3이 동일한 상품에 입청 시도 → 락 획득 실패 → 락 해제 신호 구독 상태로 전환  

   - 유저 2의 입찰 완료 후 락 해제 신호 발행 → 유저 3이 신호 수신 → 즉시 락 획득 재시도

- Lettuce의 스핀 락 방식보다 **WAS 부하 감소**  

- 블로킹 대기 방식으로 네트워크 및 Redis 부하 최소화  

- 락 해제 시 즉각적인 재시도 가능

**단점 및 주의사항**  
   
   - 단일 Redis 인스턴스에 의존 → 메시지 전달 지연 시 동기화 문제 발생 가능  
   
   - **마스터 노드 장애** 시 락 관리 불가능  
   
   - Master-Slave 복제 지연 시 노드 간 데이터 불일치 발생 위험  
   
   - Redis 클러스터 구성 시 추가적인 설정 필요

**Pub/Sub 기반의 Redission 분산 락은 Lettuce 대비 WAS 부하를 줄일 수 있지만, Redis 인프라의 가용성과 복제 지연 문제를 고려해야 함**

---

# 결론

1. 락 미사용

    - 동시성 문제 발생

2. 낙관적 락

    - 트래픽이 적을 때는 효율적, 많은 입찰이 동시에 시도되면 롤백/재시도로 인한 성능 저하로 부적합하다고 판단

3. 비관적 락

    - 낙관적 락에 비하면 동시성이 높을 때 효율적이지만 DB의 성능 저하와 병목 현상으로 데드락 발생 확률 존재

4. Lettuce 분산 락 (SETNX)

    - 빠른 성능과 확장성, DB 부하 적음

    - Spin 락 형식으로 Redis에 집중 부하가 있지만 소규모 프로젝트이며 경매에 많은 트래픽이 걸리지 않을 것이라 생각하여 적합하고 판단

5. Redisson 분산 락 (Pub/Sub)

    - Pub/Sub 기반으로 WAS 부하 최소화, 락 해제 시 즉각적인 재시도 가능

    - 단일 Redis 인스턴스 의존, 마스터 장애나 복제 지연 시 동기화 문제 가능

    - 대규모 프로젝트에 적합하다고 생각하여 부적합하다고 판단

---
### 참고

https://github.com/m020202/LiveTicketing

https://hudi.blog/distributed-lock-with-redis/

https://tech.kakaopay.com/post/troubleshooting-logs-as-a-junior-developer/
