# 데이터 구조 (Data Structure)

개발자가 데이터를 효율적으로 사용할 수 있도록 정리하는 방법

각 구조마다 장단점이 존재하여 해결하고자 하는 문제나 우선 순위에 따라 최적의 선택이 달라짐

### 데이터 구조의 중요성

1. 효율적인 데이터 관리

2. 원활한 프로그램 흐름

3. 버그 예방

4. 성능 최적화
 
### 데이터 구조와 알고리즘

- 알고리즘: 컴퓨터에 내리는 지시 사항

- 데이터 구조: 알고리즘에서 사용하는 데이터 저장 방법

  - 니클라우스 비르트: "알고리즘 + 데이터 구조 = 프로그램"

### 추상 데이터 타입 (ADT)

- 데이터 구조를 설명하는 데이터 타입

- 데이터 구조는 ADT를 실제로 구현한 결과

## 데이터 구조의 종류

1. 선형 데이터 구조(Linear Data Structure)

    - 데이터 요소를 순서대로 정렬
  
    - 각 요소의 앞뒤에 다른 요소 존재
  
    - 예: 배열, 리스트, 스택, 큐

2. 비선형 데이터 구조(Nonlinear Data Structure)

    - 데이터를 비연속적으로 연결
    
    - 각 요소가 여러 다른 요소와 연결 가능

    - 예: 트리, 그래프

### 데이터 순회 (Traverse)

- 선형 구조: 첫 요소부터 마지막 요소로 순차적 이동
  
- 비선형 구조: 백트래킹이나 재귀가 필요할 수 있음
  
### 선형 vs 비선형 구조의 적합성

- 선형 구조:

  - 개별 요소 접근이 용이

  - 전체 데이터 변경에 적합

  - 구조 설계 및 사용이 상대적으로 간단

- 비선형 구조:

  - 복잡한 관계 표현에 적합 (예: 소셜 네트워크)

  - 계층적 데이터 표현에 유용 (예: 파일 시스템)

![image](https://github.com/user-attachments/assets/45c7a416-56c5-413f-bb0d-68d50fd8e7de)
출처 : https://www.interviewbit.com/data-structure-interview-questions/


# 선형 데이터 구조의 종류

<details>
 
 <summary>배열 (Array)</summary>

 ## 배열 (Array)
 
 배열은 가장 기본적인 데이터 구조
 
 생성 시 설정된 셀의 수가 고정되며, 각 셀에는 인덱스 번호가 부여
 
 이 인덱스를 통해 셀 안의 데이터에 접근 가능
 
 ### 시간복잡도
 
 | 연산 | 평균 | 최악 |
 |------|------|------|
 | 접근 | O(1) | O(1) |
 | 검색 | O(n) | O(n) |
 | 삽입 | O(n) | O(n) |
 | 삭제 | O(n) | O(n) |
 
 ### 장점
 
 - 구현이 간단함
 - 데이터 검색 및 수정이 효율적
 - 정렬에 용이함
 
 ### 단점
 
 - 메모리 크기가 고정되어 메모리 낭비나 크기 조정 문제 발생 가능
 - 데이터 추가 및 삭제 방법이 비효율적
 
 ### 사용 사례
 
 - 직사각형 테이블 구현
 - 수학적 벡터 및 행렬 구현
 - 다른 데이터 구조의 기반으로 활용 가능
 
 배열은 간단하면서도 강력한 데이터 구조로, 많은 프로그래밍 작업의 기초
 
 고정된 크기와 빠른 접근 시간이 특징이지만, 동적인 데이터 관리에는 제한이 있을 수 있음

-----

</details>

<details>
 
 <summary>연결 리스트 (Linked List)</summary>

## 연결 리스트 (Linked List)

연결 리스트는 데이터의 물리적 배치 대신 참조 시스템을 사용하는 데이터 구조

### 주요 특징

- 각 요소(노드)에는 데이터와 다음 노드를 가리키는 포인터가 포함됨
- 노드들의 연결로 구성된 구조
- 데이터 추가 및 삭제 시 재구성이 불필요하여 효율적

### 종류

- 단일 연결 리스트: 각 노드가 다음 노드만을 가리킴
- 이중 연결 리스트: 각 노드가 이전 노드와 다음 노드를 모두 가리킴

### 시간 복잡도

| 연산 | 평균 | 최악 |
|------|------|------|
| 접근 | O(n) | O(n) |
| 검색 | O(n) | O(n) |
| 삽입 | O(1) | O(1) |
| 삭제 | O(1) | O(1) |

### 장점

- 동적 메모리 할당 가능
- 요소 추가와 삭제가 효율적
- 메모리 연속성 불필요
- 구조 재구성 불필요
- 효율적인 메모리 사용으로 대용량 데이터 처리에 적합

### 단점

- 배열보다 메모리 소모가 큼
- 임의 접근 속도가 느림
- 순차적 접근 필요로 인한 비효율성
- 이중 연결 리스트의 경우 역방향 검색 시 추가 메모리 필요

### 사용 사례

- 동적 메모리 할당이 필요한 경우
- 빈번한 데이터 삽입/제거가 필요한 경우
- 이미지 뷰어나 갤러리 애플리케이션
- 음악 플레이어
- 운영 체제의 프로세스 관리
- 웹 브라우저의 뒤로/앞으로 기능

연결 리스트는 동적 데이터 관리에 효과적이지만, 임의 접근이 필요한 경우에는 배열이 더 적합할 수 있음

-----

</details>

<details>
 
 <summary>스택 (Stack)</summary>
 
## 스택 (Stack)

스택은 순서가 보존되는 선형 데이터 구조

가장 마지막에 삽입된 요소부터 처리하는 LIFO (Last In First Out) 메커니즘

### LIFO (Last In First Out)

- 마지막에 들어온 데이터가 가장 먼저 나가는 구조
- 예: 접시 쌓기 - 가장 위에 있는 접시가 먼저 사용됨

### 주요 연산

- 푸시(Push): 스택의 맨 위에 요소 추가
- 팝(Pop): 스택의 맨 위 요소 제거 및 반환

### 시간 복잡도

| 연산 | 평균 | 최악 |
|------|------|------|
| 접근 | O(n) | O(n) |
| 검색 | O(n) | O(n) |
| 삽입 (Push) | O(1) | O(1) |
| 삭제 (Pop) | O(1) | O(1) |

### 장점

- 동적 메모리 관리 가능
- 데이터의 입력 순서대로 정렬
- 빠른 삽입 및 삭제 연산 (O(1))
- 구현이 간단하고 메모리 효율적

### 단점

- 가장 최근 요소만 직접 접근 가능
- 한 번에 하나의 데이터만 처리 가능
- 중간 데이터에 대한 접근이 어려움

### 사용 사례

- 함수 호출 관리 (콜 스택)
- 웹 브라우저의 뒤로가기 기능
- 실행 취소/다시 실행 기능
- 재귀 알고리즘 구현
- 괄호 검사 등의 구문 분석
- 후위 표기법 계산

스택은 간단하면서도 강력한 데이터 구조

특정 순서로 데이터를 관리해야 하는 다양한 상황에서 유용하게 사용

특히 최근 데이터를 빠르게 처리해야 하는 경우에 효과적

-----

</details>
 

<details>
 
 <summary>큐 (Queue)</summary>

## 큐 (Queue)

큐는 스택과 유사한 선형 데이터 구조이지만, 가장 먼저 입력된 요소를 처리하는 FIFO(First In First Out) 메커니즘

### FIFO (First In First Out)

- 먼저 들어온 데이터가 먼저 나가는 구조
- 예: 줄 서기 - 먼저 줄을 선 사람이 먼저 서비스를 받음

### 주요 연산

- 인큐(Enqueue): 큐의 뒤쪽에 요소 추가
- 디큐(Dequeue): 큐의 앞쪽에서 요소 제거 및 반환

### 시간 복잡도

| 연산 | 평균 | 최악 |
|------|------|------|
| 접근 | O(n) | O(n) |
| 검색 | O(n) | O(n) |
| 삽입 (Enqueue) | O(1) | O(1) |
| 삭제 (Dequeue) | O(1) | O(1) |

### 장점

- 동적 메모리 관리 가능
- 데이터를 입력 순서대로 처리
- 빠른 삽입 및 삭제 연산 (O(1))
- 데이터 흐름 관리에 효과적

### 단점

- 가장 오래된 요소만 직접 접근 가능
- 한 번에 하나의 데이터만 처리 가능
- 중간 데이터에 대한 임의 접근 어려움

### 사용 사례

- 비동기적 데이터 전송 (버퍼링)
- 순서에 민감한 데이터 처리 (음성 데이터 등)
- 프린트 대기열 관리
- 캐시 구현
- 작업 예약 시스템
- 웹 서버의 요청 처리
- 너비 우선 탐색(BFS) 알고리즘 구현

큐는 데이터를 순서대로 처리해야 하는 다양한 상황에서 유용하게 사용
특히 선입선출 방식의 처리가 필요한 시스템 설계에 적합

-----

</details>

# 비선형 데이터 구조의 종류

<details>
 
 <summary>해시 테이블 (Hash Table / Hash Map)</summary>

## 해시 테이블 (Hash Table / Hash Map)

해시 테이블은 대량의 정보를 저장하고 특정 요소를 효율적으로 검색할 수 있는 복잡한 데이터 구조

### 구조 및 작동 원리

- 테이블 내에 더 작은 서브 그룹인 버킷에 키와 값 쌍을 저장
- 키를 해시 함수를 통해 특정 숫자값(해시)으로 변환
- 해시 값은 버킷의 인덱스로 사용됨
- 검색 시 키를 해시 함수에 입력하여 해당 버킷을 찾고 관련 값을 반환

### 시간 복잡도

| 연산 | 평균 | 최악 |
|------|------|------|
| 접근 | N/A | N/A |
| 검색 | O(1) | O(n) |
| 삽입 | O(1) | O(n) |
| 삭제 | O(1) | O(n) |

### 장점

- 요소의 추가 및 삭제가 효율적
- 검색과 접근이 매우 빠름 (평균 O(1))
- 동적 메모리 크기 조정 가능
- 키-값 쌍의 저장에 이상적

### 단점

- 해시 충돌 발생 가능 (서로 다른 키가 같은 해시 값을 가질 수 있음)
- 충돌 해결을 위한 추가 메커니즘 필요
- 해시 함수의 성능에 크게 의존
- 순서가 보장되지 않음

### 사용 사례

- 데이터베이스 인덱싱 (주소, 이름, 번호 검색)
- 사용자 인증 시스템
- 캐싱 시스템
- 중복 제거
- 암호화 및 보안 응용 프로그램
- 컴파일러의 심볼 테이블

해시 테이블은 빠른 데이터 검색과 삽입이 필요한 다양한 응용 프로그램에서 널리 사용

효율적인 해시 함수 설계와 충돌 해결 전략이 필요

-----

</details>

<details>
 
 <summary>트리 (Tree)</summary>
 
## 트리 (Tree)

트리는 노드로 구성된 계층적 데이터 구조

최상위 노드(루트)에서 시작하여 자식 노드들을 추가하는 방식으로 구현

### 주요 개념

- **노드 (Node)**: 트리의 기본 구성 요소
- **루트 (Root)**: 트리의 최상위 노드
- **부모 노드**: 직접 연결된 상위 노드
- **자식 노드**: 직접 연결된 하위 노드
- **깊이 (Depth)**: 루트에서 특정 노드까지의 거리
- **형제 (Sibling)**: 같은 부모를 가진 노드들
- **간선 (Edge)**: 노드와 노드를 잇는 선
- **리프 (Leaf)**: 자식이 없는 노드

### 트리의 종류

- 이진 트리
- 이진 검색 트리
- AVL 트리
- 레드-블랙 트리
- B-트리

### 시간 복잡도 (이진 검색 트리 기준)

| 연산 | 평균 | 최악 |
|------|------|------|
| 접근 | O(log n) | O(n) |
| 검색 | O(log n) | O(n) |
| 삽입 | O(log n) | O(n) |
| 삭제 | O(log n) | O(n) |

### 장점

- 계층적 데이터 표현에 적합
- 효율적인 검색 및 삽입 연산 (균형 잡힌 경우)
- 동적 크기 조정 가능
- 데이터의 정렬 상태 유지 가능

### 단점

- 불균형 상태에서 성능 저하 가능
- 구현이 상대적으로 복잡
- 일부 연산에서 재귀 사용으로 인한 스택 오버플로우 위험

### 사용 사례

- 파일 시스템 구조
- 데이터베이스 인덱싱
- 문법 분석 (구문 트리)
- 결정 트리 (의사 결정 모델)
- 네트워크 라우팅 테이블
- 게임의 AI (미니맥스 알고리즘)

트리 구조는 계층적 관계를 가진 데이터를 효율적으로 저장하고 검색하는 데 매우 유용

특히 검색, 삽입, 삭제 연산이 빈번한 경우에 효과적으로 사용

-----

</details>
 
<details>
 
 <summary>그래프 (Graph)</summary>

## 그래프 (Graph)

그래프는 노드(nodes) 또는 정점(vertices)과 이들을 연결하는 엣지(edges)로 구성된 데이터 구조

### 주요 개념

- **노드/정점**: 그래프의 기본 요소
- **엣지**: 노드 간의 연결을 나타내는 선
- **방향 그래프(Directed Graph)**: 엣지에 방향성이 있는 그래프
- **무방향 그래프(Undirected Graph)**: 엣지에 방향성이 없는 그래프
- **가중치 그래프(Weighted Graph)**: 엣지에 가중치가 할당된 그래프

### 시간 복잡도 (인접 리스트 기준)

| 연산 | 평균 | 최악 |
|------|------|------|
| 정점 추가 | O(1) | O(1) |
| 엣지 추가 | O(1) | O(1) |
| 정점 제거 | O(V + E) | O(V + E) |
| 엣지 제거 | O(E) | O(E) |
| 검색 | O(V) | O(V) |

V: 정점의 수, E: 엣지의 수

### 장점

- 복잡한 관계와 네트워크를 효과적으로 모델링 가능
- 요소의 추가 및 삭제가 용이하고 효율적
- 다양한 실제 상황에 적용 가능한 유연한 구조
- 경로 찾기 및 최적화 문제에 효과적

### 단점

- 메모리 사용량이 많을 수 있음 (특히 밀집 그래프의 경우)
- 구현이 복잡할 수 있음
- 대규모 그래프의 경우 처리 시간이 길어질 수 있음
- 일부 연산의 시간 복잡도가 그래프의 크기에 크게 의존함

### 사용 사례

- 소셜 네트워크 분석 및 모델링
- 교통 시스템 및 네트워크 라우팅
- 웹 페이지와 하이퍼링크 구조 분석
- 추천 시스템
- 생물학적 네트워크 (단백질 상호작용 등)
- 컴퓨터 네트워크 토폴로지
- 게임의 레벨 디자인

그래프는 복잡한 관계를 표현하고 분석하는 데 매우 유용한 데이터 구조

그래프의 구조와 알고리즘 선택에 따라 성능이 크게 달라질 수 있으므로, 특정 문제에 적합한 그래프 표현 방식과 알고리즘을 선택하는 것이 중요

-----

</details>

<details>
 
 <summary>셋 (Set)</summary>
 
## 셋 (Set)

셋은 중복되지 않는 요소들의 집합을 나타내는 데이터 구조

### 주요 특징

- 요소의 순서가 없음
- 중복 요소를 허용하지 않음
- 수학적 집합 연산 (합집합, 교집합, 차집합) 지원

### 시간 복잡도 (해시 셋 기준)

| 연산 | 평균 | 최악 |
|------|------|------|
| 접근 | N/A | N/A |
| 검색 | O(1) | O(n) |
| 삽입 | O(1) | O(n) |
| 삭제 | O(1) | O(n) |

### 장점

- 빠른 요소 검색 및 중복 제거
- 집합 연산의 효율적 수행
- 메모리 효율성 (중복 저장 방지)

### 단점

- 요소의 순서를 유지하지 않음
- 인덱스로 접근 불가
- 일부 구현에서 해시 충돌 가능성

### 사용 사례

- 중복 제거
- 고유 값 관리
- 데이터 비교 및 분석
- 캐싱 시스템
- 그래프 알고리즘 (방문한 노드 추적 등)

테이블과 셋은 각각 고유한 특성을 가진 데이터 구조

테이블은 구조화된 데이터 관리에, 셋은 고유성이 중요한 데이터 처리에 주로 사용

-----

</details>

-----

## 정적 vs 동적 데이터 구조

### 정적 데이터 구조

- 생성 시 크기가 정의되며 이후 수정 불가
- 저장된 데이터의 값은 수정 가능
- 일정량의 메모리를 미리 할당
- 할당된 메모리가 데이터 요소보다 크면 메모리 낭비 발생
- C언어에서 지원, 파이썬에서는 지원하지 않음

### 동적 데이터 구조

- 크기를 자유롭게 수정 가능
- 요소 추가 시 컴퓨터가 추가 메모리 할당
- 요소 제거 시 메모리 해제, 다른 데이터 사용 가능
- 메모리를 더 효율적으로 사용
- 일정 수의 요소 저장 시 더 많은 메모리 사용 가능
- 요소 접근 작업이 정적에 비해 느릴 수 있음

### 선택 기준

- 극한의 효율이 필요한 상황이 아니라면 정적 또는 동적보다는 선형 또는 비선형 데이터 구조 선택에 집중하는 것이 효율적
- 데이터의 삽입, 삭제, 탐색의 효율성 고려
- 메모리 공간의 효율적 사용 판단


-----

### 참고 자료
- [한빛출판네트워크_자료구조의 개념과 종류](https://www.hanbit.co.kr/channel/category/category_view.html?cms_code=CMS2832062046)
- [프로 개발자로 성장하기 위해 필요한 기초역량, 자료구조](https://medium.com/supercent-blog/%EA%B0%9C%EB%B0%9C-%EC%8B%A4%EB%A0%A5%EC%9D%80-%EC%9D%B4%EA%B1%B0%EB%A1%9C-%EA%B2%B0%EC%A0%95%EB%90%A9%EB%8B%88%EB%8B%A4-feat-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-5df45670ea8d)
- https://www.interviewbit.com/data-structure-interview-questions/
- [개발자라면 꼭 알아야 할 7가지 자료구조](https://velog.io/@jha0402/Data-structure-%EA%B0%9C%EB%B0%9C%EC%9E%90%EB%9D%BC%EB%A9%B4-%EA%BC%AD-%EC%95%8C%EC%95%84%EC%95%BC-%ED%95%A0-7%EA%B0%80%EC%A7%80-%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0)
- [데이터 구조란 무엇입니까? 정의 및 유형](https://appmaster.io/ko/blog/deiteo-gujo-jeongyi-mic-yuhyeongeun-mueosibnigga)

