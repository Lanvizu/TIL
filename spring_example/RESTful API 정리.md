# RESTful API

RESTful API는 두 컴퓨터 시스템이 인터넷을 통해 안전하게 정보를 교환하기 위한 인터페이스

소프트웨어 통신 표준을 따르므로 안전하고 신뢰할 수 있는 방법으로 정보 교환이 가능

## API (Application Programming Interface)

- 정의: 다른 소프트웨어 시스템과 통신하기 위해 따라야 하는 규칙
  
- 예시: 근무 시간 기록 애플리케이션에서 직원 정보와 날짜 범위를 요청하고 근무 시간을 반환하는 과정

### 주요 구성 요소

1. **클라이언트**: 정보에 액세스하려는 사용자 또는 소프트웨어 시스템
   
2. **리소스**: 애플리케이션이 클라이언트에게 제공하는 정보 (텍스트, 숫자, 이미지, 동영상 등)
   
3. **서버**: 클라이언트에게 리소스를 제공하는 시스템

## REST (Representational State Transfer)

REST는 API 동작 방식에 대한 조건을 부과하는 소프트웨어 아키텍처

### 특징

- 대규모의 고성능 통신을 안정적으로 지원
  
- 쉬운 구현 및 수정 가능
  
- 여러 플랫폼에서 사용 가능

### REST 아키텍처의 주요 원칙

1. **균일한 인터페이스**
   
   - 서버가 표준 형식으로 정보 전송
     
   - 4가지 아키텍처 제약 조건 준수
     
    1. **리소스 식별**
       
       - 요구사항: 모든 요청은 리소스를 명확히 식별해야 함
         
       - 구현: 균일한 리소스 식별자(URI) 사용
    
    2. **표현을 통한 리소스 조작**
       
       - 요구사항: 클라이언트가 리소스 수정/삭제에 필요한 정보를 보유
         
       - 구현: 서버가 리소스에 대한 상세 메타데이터 제공
    
    3. **자기 서술적 메시지**
       
       - 요구사항: 클라이언트가 리소스 처리 방법 정보를 수신
         
       - 구현: 서버가 리소스 사용법에 대한 메타데이터가 포함된 명확한 메시지 전송
    
    4. **하이퍼미디어 as the Engine of Application State (HATEOAS)**
       
       - 요구사항: 클라이언트가 관련 리소스 정보를 수신
         
       - 구현: 서버가 리소스 표현에 하이퍼링크를 포함하여 동적 리소스 검색 지원


2. **무상태**
   
   - 서버가 모든 클라이언트 요청을 독립적으로 처리
     
   - 클라이언트는 임의의 순서로 리소스 요청 가능

3. **계층화 시스템**
   
   - 클라이언트와 서버 사이에 중개자 존재 가능
     
   - 여러 계층으로 구성된 서버 설계 가능

4. **캐시 가능성**
   
   - 서버 응답 시간 개선을 위한 캐싱 지원

     - ex) 웹 사이트 페이지에 공통된 이미지나 리소스를 제공할 때 방문할 때 마다 서버가 동일한 이미지를 전송해야 함
       
     - 이를 피하기 위해 첫 번째 응답 후 해당 이미지를 캐싱하거나 저장하여 다음 캐시에서 직접 이미지를 사용
     
   - API 응답을 통해 캐싱 제어 가능

5. **온디맨드 코드**
    
   - 서버가 클라이언트에 소프트웨어 코드 전송 가능
     
   - 클라이언트 기능의 일시적 확장 또는 사용자 지정 가능

## RESTful API의 이점

### 확장성
- 클라이언트-서버 상호 작용 최적화로 효율적인 크기 조정 가능
- 무상태 특성으로 서버 로드 감소
- 캐싱을 통한 상호 작용 최소화
- 성능 저하 없는 확장성 지원

### 유연성
- 완전한 클라이언트-서버 분리 지원
- 서버 구성 요소의 독립적 발전 가능
- 서버 기술 변경이 클라이언트에 영향을 주지 않음
- 계층화를 통한 유연성 향상

### 독립성
- 사용 기술과 독립적인 API 설계
- 다양한 프로그래밍 언어로 클라이언트 및 서버 애플리케이션 구현 가능
- 기본 기술 변경이 통신에 영향을 주지 않음

## RESTful API 작동 원리

1. 클라이언트가 서버에 요청 전송 (API 문서 기반)
2. 서버가 클라이언트 인증 및 권한 확인
3. 서버가 요청 처리
4. 서버가 클라이언트에 응답 반환 (성공 여부 및 요청 정보 포함)

## RESTful API 클라이언트 요청 구성 요소

### 1. 고유 리소스 식별자 (URL)
- 서버의 각 리소스를 식별하는 고유한 주소
- 예: `https://api.example.com/users/123`

### 2. HTTP 메서드
- GET: 리소스 조회
- POST: 새 리소스 생성
- PUT: 기존 리소스 업데이트
- DELETE: 리소스 삭제

### 3. HTTP 헤더
- 클라이언트와 서버 간 메타데이터 교환
- 요청/응답 형식, 상태 정보 등 제공
- 예: `Content-Type: application/json`

### 4. 데이터 (선택적)
- POST, PUT 등의 메서드에서 사용
- 리소스 생성 또는 수정에 필요한 정보 포함

### 5. 파라미터 (선택적)
- 경로 파라미터: URL 일부로 리소스 지정
- 쿼리 파라미터: 추가 정보 요청
- 쿠키 파라미터: 클라이언트 인증 등에 사용

## RESTful API의 인증 방법

RESTful API에서 인증은 클라이언트의 신원을 확인하고 리소스에 대한 접근 권한을 부여하는 중요한 프로세스

### 1. HTTP 인증

#### 기본 인증 (Basic Authentication)
- 작동 방식: 클라이언트가 사용자명과 암호를 Base64로 인코딩하여 요청 헤더에 포함
- 예시: `Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ=`
- 장점: 구현이 간단함
- 단점: 보안성이 낮음, HTTPS 사용 필수

#### 전달자 인증 (Bearer Authentication)
- 작동 방식: 클라이언트가 토큰을 요청 헤더에 포함
- 예시: `Authorization: Bearer <token>`
- 장점: 사용자 자격 증명을 직접 전송하지 않음
- 단점: 토큰 관리 필요

### 2. API 키

- 작동 방식: 서버가 클라이언트에 고유한 키를 발급, 클라이언트는 요청 시 이 키를 포함
- 예시: `api_key=abcdefghijklmnopqrstuvwxyz123456`
- 장점: 구현과 사용이 간단함
- 단점: 키가 노출될 경우 보안 위험

### 3. OAuth 2.0

- 작동 방식: 클라이언트가 사용자 동의를 받아 접근 토큰을 발급받고 이를 사용
- 단계:
  1. 클라이언트가 인증 서버에 인증 요청
  2. 사용자 동의 획득
  3. 인증 코드 발급
  4. 접근 토큰 발급
  5. 리소스 서버에 접근 토큰으로 요청
- 장점: 높은 보안성, 세분화된 권한 제어
- 단점: 구현이 복잡함

### 4. JWT (JSON Web Tokens)

- 작동 방식: 클레임 정보를 JSON 객체로 안전하게 전송
- 구조: Header.Payload.Signature
- 장점: 상태를 저장할 필요 없음, 확장성이 좋음
- 단점: 토큰 크기가 상대적으로 큼

### 5. OpenID Connect

- OAuth 2.0의 확장으로, 인증 레이어 추가
- 사용자 정보를 표준화된 방식으로 제공
- 장점: 표준화된 사용자 정보 제공, Single Sign-On 지원
- 단점: 구현 복잡도가 높음

### 보안 고려사항

1. HTTPS 사용: 모든 API 통신에 HTTPS 적용 필수
2. 토큰 만료: 접근 토큰에 적절한 만료 시간 설정
3. 비밀 정보 보호: API 키, 클라이언트 비밀 등을 안전하게 관리
4. 속도 제한: 과도한 요청을 방지하기 위한 속도 제한 구현
