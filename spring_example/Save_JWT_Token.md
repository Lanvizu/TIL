[JWT](https://github.com/Lanvizu/TIL/blob/main/spring_example/JWT.md)
이전 JWT 정리 후 프로젝트에 적용하면서 Access Token과 Refresh Token을 어디에 저장할지 공부하며 정리한 글이다.

(미완)
-----

사용자 인증 - 시스템이나 애플리케이션에 접근하려는 사용자가 실제로 그 사용자가 맞는지 확인하는 과정.

session 인증 방식
서버에 상태를 저장하는 상태유지(stateful)
로그인 시 -> 서버로 요청 -> 요청 정보가 DB와 일치 확인 -> 사용자의 세션 생성 -> 해당 세션 ID를 서버나 메모리에 저장
이후 쿠키에 담아 사용자의 후속 요청마다 세션 ID 담긴 쿠키를 서버로 전송 -> 해당 세션 ID가 저장소에 존재하는지 확인

서버에서 인증을 관리하므로 클라이언트 측에서 정보 노출 위험이 적음
하지만 사용자 요청마다 DB에 접근 -> 응답 속도 저하 -> 서버 부하 원인

토큰 인증 방식
세션 방식과 달리 서버에 상태를 저장하지 않음 - 상태 비저장(Stateless)
DB에 거치지 않고 오로지 토큰을 이용한 방법 (서버를 안거치는것이 아니므)

서버를 거치지 않아 응답속도 저하 문제 해결
확장성면에서도 우수함 (이유는?)

그러나 토큰을 탈취당할 위험이 있다.
악성코드(XSS)로 탈취당하거나 클라이언트에서 서버로 전송 중 탈취
탈취당해도 서버쪽에서 탈취를 감지하기도 어렵고 강제로 해제도 불가 <-> 블랙리스트로 설정하는 방법이 있긴함 (탈취 감지 가능 시)

Access Token - 사용자의 인증과 권한을 단기 유효 토큰(문자열)
클라이언트 -> 서버  API 요청 보낼 때 해당 토큰을 헤더에 포함 + 요청 -> 액세스 토큰이 유효한지 검증

JWT의 페이로드 내부에 사용자의 정보를 통해 DB 접근 없이 확인 가능 + 서명 부분을 통해 변조 감지 가능

Access Token 저장 위치
로컬 스토리지

클라이언트 측에 데이터를 영구적으로 저장하는 방법
브라우저를 닫아도 유지되며, 클라이언트가 명시적으로 삭제하지 않는 한 유지
XSS에 취약함 (왜?) -> 악성 코드가 로컬 스토리지의 저장된 액세스 토큰을 탈취 가능 


세션 스토리지

브라우저가 닫히면 데이터가 삭제되며, 같은 탭에서만 유효하다.
로컬 스토리지 보단 안전하지만, 아직 XSS 공격에 취약함


쿠키

HTTP의 무상태(stateless) 특성을 보완하기 위해 등장한 데이터 쪼가리
모든 클라이언트 요청에 자동적으로 포함 -> 클라이언트에서 쿠키를 별도로 포함시키지 않아도 된다.
영구 쿠키와 세션 쿠키가 있는데 브라우저가 닫힐 때 사라지는 세션 쿠키로 사용

HTTP Only 플래그를 사용해 JavaScript에서 쿠키에 접근할 수 없도록 설정 -> XSS 공격에 대한 보안을 높이는 방식
하지만 다양한 XSS 공격에 대해서 완벽하게 방어된다고 볼 수 없다.

Secuer플래그를 사용해 HTTPS 연결에만 쿠키가 전송되게 설정 -> 중간자 공격(MITM)으로부터 쿠키 보호 가능
SameSite 플래그를 통해 CSRF(교차 사이트 요청 위조) 공격 방어 가능

메모리

Access Token을 서버의 메모리에 저장하는 방식
예를 들어 JavaScript의 private 변수에 저장 -> 매 요청마다 Api 호출 시 Access Token 접근이 쉬워진다.
브라우저의 메모리는 세션 단위로 관리되기 때문에 페이지 이동시 Access Token 사라짐

하지만 SPA(Single Page Application)를 사용하면 페이지를 이동하는 것 처럼 보여 실제로는 이동하지 않으므로 private 변수가 유지된다.
새로고침을 하게되면 private 변수가 소멸되어 다시 로그인 해야함

스크립트를 통해서 메모리 공간을 직접적으로 제어할 수 없으므로 XSS 공격에 의해 쉽게 탈취 불가
하지만 이 또한 완벽하게 방어되기는 어렵다.
웹 애플리케이션 자체에 XSS 취약점이 있다면 악의적인 스크립트를 통해 탈취 가능성 있음

XSS
CSRF 정리









### 참고

https://olrlobt.tistory.com/98


