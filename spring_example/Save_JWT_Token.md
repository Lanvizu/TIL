[JWT](https://github.com/Lanvizu/TIL/blob/main/spring_example/JWT.md)
이전 JWT 정리 후 프로젝트에 적용하면서 Access Token과 Refresh Token을 어디에 저장할지 공부하며 정리한 글이다.

(미완)
-----

사용자 인증 - 시스템이나 애플리케이션에 접근하려는 사용자가 실제로 그 사용자가 맞는지 확인하는 과정.

session 인증 방식
서버에 상태를 저장하는 상태유지(stateful)
로그인 시 -> 서버로 요청 -> 요청 정보가 DB와 일치 확인 -> 사용자의 세션 생성 -> 해당 세션 ID를 서버나 메모리에 저장
이후 쿠키에 담아 사용자의 후속 요청마다 세션 ID 담긴 쿠키를 서버로 전송 -> 해당 세션 ID가 저장소에 존재하는지 확인

서버에서 인증을 관리하므로 클라이언트 측에서 정보 노출 위험이 적음
하지만 사용자 요청마다 DB에 접근 -> 응답 속도 저하 -> 서버 부하 원인

토큰 인증 방식
세션 방식과 달리 서버에 상태를 저장하지 않음 - 상태 비저장(Stateless)
DB에 거치지 않고 오로지 토큰을 이용한 방법 (서버를 안거치는것이 아니므)

서버를 거치지 않아 응답속도 저하 문제 해결
확장성면에서도 우수함 (이유는?)

그러나 토큰을 탈취당할 위험이 있다.
악성코드(XSS)로 탈취당하거나 클라이언트에서 서버로 전송 중 탈취
탈취당해도 서버쪽에서 탈취를 감지하기도 어렵고 강제로 해제도 불가 <-> 블랙리스트로 설정하는 방법이 있긴함 (탈취 감지 가능 시)

Access Token - 사용자의 인증과 권한을 단기 유효 토큰(문자열)
클라이언트 -> 서버  API 요청 보낼 때 해당 토큰을 헤더에 포함 + 요청 -> 액세스 토큰이 유효한지 검증

JWT의 페이로드 내부에 사용자의 정보를 통해 DB 접근 없이 확인 가능 + 서명 부분을 통해 변조 감지 가능

Access Token 저장 위치
로컬 스토리지

클라이언트 측에 데이터를 영구적으로 저장하는 방법
브라우저를 닫아도 유지되며, 클라이언트가 명시적으로 삭제하지 않는 한 유지
XSS에 취약함 (왜?) -> 악성 코드가 로컬 스토리지의 저장된 액세스 토큰을 탈취 가능 


세션 스토리지

브라우저가 닫히면 데이터가 삭제되며, 같은 탭에서만 유효하다.
로컬 스토리지 보단 안전하지만, 아직 XSS 공격에 취약함


쿠키

HTTP의 무상태(stateless) 특성을 보완하기 위해 등장한 데이터 쪼가리
모든 클라이언트 요청에 자동적으로 포함 -> 클라이언트에서 쿠키를 별도로 포함시키지 않아도 된다.
영구 쿠키와 세션 쿠키가 있는데 브라우저가 닫힐 때 사라지는 세션 쿠키로 사용

HTTP Only 플래그를 사용해 JavaScript에서 쿠키에 접근할 수 없도록 설정 -> XSS 공격에 대한 보안을 높이는 방식
하지만 다양한 XSS 공격에 대해서 완벽하게 방어된다고 볼 수 없다.

Secuer플래그를 사용해 HTTPS 연결에만 쿠키가 전송되게 설정 -> 중간자 공격(MITM)으로부터 쿠키 보호 가능
SameSite 플래그를 통해 CSRF(교차 사이트 요청 위조) 공격 방어 가능

메모리

Access Token을 서버의 메모리에 저장하는 방식
예를 들어 JavaScript의 private 변수에 저장 -> 매 요청마다 Api 호출 시 Access Token 접근이 쉬워진다.
브라우저의 메모리는 세션 단위로 관리되기 때문에 페이지 이동시 Access Token 사라짐

하지만 SPA(Single Page Application)를 사용하면 페이지를 이동하는 것 처럼 보여 실제로는 이동하지 않으므로 private 변수가 유지된다.
새로고침을 하게되면 private 변수가 소멸되어 다시 로그인 해야함

스크립트를 통해서 메모리 공간을 직접적으로 제어할 수 없으므로 XSS 공격에 의해 쉽게 탈취 불가
하지만 이 또한 완벽하게 방어되기는 어렵다.
웹 애플리케이션 자체에 XSS 취약점이 있다면 악의적인 스크립트를 통해 탈취 가능성 있음

XSS
CSRF 정리

Refresh Token - Access Token을 재발급하기 위한 토큰

Access Token이 만료되면 클라이언트는 RefreshToken을 통해 서버로 부터 AccessToken을 재발급
-> 연속적인 사용자 인증이 가능, 사용자가 다시 로그인할 필요 없어짐

하지만 만료기간이 Access Token에 비해 길어 탈취당할 경우 해커가 Access Token을 재발급 가능 
-> Refresh Token의 보안성이 더 중요

Refresh Token 역시 JWT로 구현
페이로드 부분의 최소한의 데이터를 가지고 DB에 접근하여 Access Token 재발급

AccessToken과 마찬가지로 Self-cotained(자체 데이터 포함) 특징으로 DB이 접근을 없앨 수 있지만 
AccessToken의 유효성 연장 이외의 정보들을 포함하여 보안적으로 취약점이 생길 수 있다.
-> self-contained 특성은 사용하지 않도록 하자

refreshtoken의 저장 위치

accestoken과 동일하게 
로컬스토리지
세션스토리지
Http-only 쿠키
메모리

추가로 서버 DB에서 관리
쿠키 보다는 보안적으로 우수한 서버를 사용한 방식

RTR (Refresh Token Rotation)

Refresh Token이 단 한번의 재발급만 허용하는 방식으로
한번의 재발급을 진행할 때 Refresh Token 또한 재발급 받는다.
이때 사용자와 연결된 모든 Refresh Token은 무효화 시킨다. -> 해커가 먼저 재발급 요청을 한 경우를 방지하기 위해.

즉 해커든 사용자든 Refresh Token에 대한 Replay Attack이 감지되면 토큰을 모두 무효화시키는 방법으로 보안을 강화

----

나는 내 프로젝트인 NIHo에 적용하기 위해 적합한 조합을 찾아봤다.

Access Token은 로컬과 세션 스토리지를 통한 방법은 XSS 공격에 위험해 배제했다.
쿠키와 메모리 방식을 후보에 둔 상태로 Refresh Token 방식을 고민


토큰 방식으로 진행할 때의 장점중 stateless를 유지하기 위해 refresh token 역시 쿠키에 저장하는 것을 고민했다.
하지만 Redis 서버를 사용하게되면 찾는 시간이 약 O(1) 로 매우 작게 걸린다고 한다 -> 정보 추가 필요
또한 Access Token보다 보안적으로 더 중요하다고 생각해 서버(Redis)에 저장하는 방식을 선택하는 것이 좋다고 판단.
그리고 RTR을 적용시킨다.
이때 Access Token으로 메모리 방식을 선택한다면 새로고침을 할때마다 매번 새롭게 로그인을 해야하므로 사용자가 불편할 것이라 생각했으며,
메모리 방식 역시 XSS 공격에 완벽하게 보호되지 않으므로 쿠키를 사용하여 추가 설정을 통해 보안을 강화하는 방식을 선택했다.









### 참고

https://olrlobt.tistory.com/98


