인프런 강의 '스프링 핵심 원리 - 기본편'를 공부하며 정리한 내용입니다.

[스프링 핵심 원리 - 기본편](https://www.inflearn.com/course/%EC%8A%A4%ED%94%84%EB%A7%81-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-%EA%B8%B0%EB%B3%B8%ED%8E%B8)

-----

![image](https://github.com/user-attachments/assets/18c9257a-3f7e-4527-b750-1720f3f397fb)

참고 : [애자일 소프트웨어 개발 선언](https://agilemanifesto.org/iso/ko/manifesto.html)

할인 정책을 수정

```JAVA
public class OrderServiceImpl implements OrderService {

    private final MemberRepository memberRepository = new MemoryMemberRepository();
    private final DiscountPolicy discountPolicy = new RateDiscountPolicy();
//    private final DiscountPolicy discountPolicy = new FixDiscountPolicy();

    @Override
    public Order createOrder(Long memberId, String itemName, int itemPrice) {
        Member member = memberRepository.findById(memberId);
        int discountPrice = discountPolicy.discount(member, itemPrice);

        return new Order(memberId, itemName, itemPrice, discountPrice);
    }
}
```

### DIP 위반 발생

DiscountPolicy라는 인터페이스와 RateDiscountPolicy의 구현을 모두 의존하는 상황이다.

-  추상(인터페이스) 뿐만 아니라 구체(구현) 클래스에도 의존

![image](https://github.com/user-attachments/assets/c7f57bf6-425a-4d19-b550-de1314bc9482)

### OCP 위반 발생

할인 정책을 변경하게 되면 OrderServiceImpl 내부의 코드를 수정해야한다.

- 기능을 확장해서 변경하면, 클라이언트 코드에 영향을 준다

![image](https://github.com/user-attachments/assets/f16f017f-429c-46c0-abc6-5de2bf881376)


## 관심사의 분리

애플리케이션을 하나의 공연, 인터페이스를 배역이라 생각해보자.

배역에 맞는 배우(구현)은 누가 선택하는건지 고민해야한다.

이는 배우(구현)이 정하는 것이 아니라 공연 기획자(AppConfig)가 정하는 것이다.

# AppConfig

**구현 객체를 생성**하고 **연결**하는 책임을 가지는 별도의 설정 클래스

``` JAVA
public class AppConfig {
        public MemberService memberService() {
            return new MemberServiceImpl(new MemoryMemberRepository());
        }
        public OrderService orderService() {
            return new OrderServiceImpl(
                    new MemoryMemberRepository(),
                    new FixDiscountPolicy());
        }
    }
```

- 실제 동작에 필요한 구현 객체를 생성한다.
  
- 생성한 객체 인스턴스의 참조(인스턴스)를 생성자를 통해서 주입(연결)해준다.

 ```JAVA
public class MemberServiceImpl implements MemberService {

// 생성자를 통해서 구현 -> AppConfig 안에서 구체적인 설정
// 생성자 주입!
    private final MemberRepository memberRepository;

    public MemberServiceImpl(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Override
    public void join(Member member) {
         memberRepository.save(member);
     }

     @Override
    public Member findMember(Long memberId) {
        return memberRepository.findById(memberId);
     }
}
```

- 이렇게 구현하면 의존관계에 대한 고민은 외부에 맡기고 실행에만 집중할 수 있다.

![image](https://github.com/user-attachments/assets/5c347471-760c-47d4-9151-157326532e97)

해당 그림과 같이 객체의 생성과 연결은 이제 AppConfig가 담당한다.

> DIP 완성

- MemberServiceImpl 은 MemberRepository 인 추상에만 의존하면 된다.

> 관심사의 분리

- 객체를 생성하고 연결하는 역할과 실행하는 역할이 명확히 분리되었다.

![image](https://github.com/user-attachments/assets/04d1ad7f-d8d5-46d7-9b85-a69eaf95e164)

클라이언트인 memberServiceImpl 입장에서 보면 의존관계를 외부에서 주입하는 상황

> DI(Dependency Injection) : 의존관계 주입 또는 의존성 주입


## AppConfig 리팩토링

![image](https://github.com/user-attachments/assets/dbd12940-2f4b-42bd-b1c4-d99b007e00cd)

해당 구조를 한 눈에 파악하기 쉽도록 AppConfig 클래스를 수정하자

``` Java
public class AppConfig {

    public MemberService memberService(){
        return new MemberServiceImpl(memberRepository());
    }

    private static MemoryMemberRepository memberRepository() {
        return new MemoryMemberRepository();
    }

    public OrderService orderService(){
        return new OrderServiceImpl(memberRepository(), discountPolicy());
    }

    public DiscountPolicy discountPolicy(){
        return new FixDiscountPolicy();
    }
}

```
